#! /usr/bin/env python3

""" # TODO """

# TODO - Ant - Partial functions instead of the if/else


import argparse
import cmd
import configparser
import functools
import glob
import json
import os
import pathlib
import re
import shlex
import sys
import textwrap
import time
from contextlib import suppress
from typing import Any, Callable, List, NoReturn, TypeVar, Union

from _tool_helpers import (
    Colors,
    capture_file,
    colorize_cmd_prompt,
    colorize_output,
    colorize_str,
    do_help,
    do_history,
    do_shell,
    get_engine_config,
    history_setup,
    print_error,
    print_info,
    print_response,
    print_warning,
    response_reformat_json,
    response_to_clipboard,
    response_to_file,
)
from senzing import SzAbstractFactory, SzEngineFlags, SzError

WrappedFunc = TypeVar("WrappedFunc", bound=Callable[..., Any])


MODULE_NAME = pathlib.Path(__file__).stem

# Per command JSON formatting options
PER_CMD_FORMATTERS = [
    "json",
    "jsonl",
    "color",
    "colour",
    "nocolor",
    "nocolour",
]


# -------------------------------------------------------------------------
# Metadata
# -------------------------------------------------------------------------

__all__ = ["SzCmdShell"]
__version__ = "0.0.1"  # See https://www.python.org/dev/peps/pep-0396/
__date__ = "2024-06-13"
__updated__ = "2024-06-13"

# Due to the way the Cmd module works, don't want doc strings on everything
# pylint: disable=missing-function-docstring


# -------------------------------------------------------------------------
# Decorators
# -------------------------------------------------------------------------


def sz_cmds_decorator(
    cmd_has_args: bool = True,
) -> Callable[[WrappedFunc], WrappedFunc]:
    """Decorator for do_* methods to parse args, display help, set response variables etc."""

    def decorator(do_method: WrappedFunc) -> Any:
        @functools.wraps(do_method)
        def wrapped_func(self: "SzCmdShell", *args: Any, **kwargs: Any) -> Any:
            # Apply and remove any command formatters such as jsonl, nocolor, etc
            cmd_args = self.apply_formats(args[0])

            if cmd_has_args:
                try:
                    # Parse arguments for a command and add to kwargs to use in calling do_ method
                    # Returns an argparse.Namespace, make a dict for logic checking and less complaints from mypy!
                    kwargs["parsed_args"] = self.parser.parse_args([f"{do_method.__name__[3:]}"] + self.parse(cmd_args))

                    # If the command has flags build the int value for the do_ method
                    if hasattr(kwargs["parsed_args"], "flags") and kwargs["parsed_args"].flags:
                        kwargs["flags"] = get_sz_engine_flags(kwargs["parsed_args"].flags)

                    # If the command uses *_record_keys build the expected list of tuples for the SDK
                    if hasattr(kwargs["parsed_args"], "record_keys") or hasattr(
                        kwargs["parsed_args"], "avoid_record_keys"
                    ):
                        record_keys = (
                            kwargs["parsed_args"].record_keys
                            if hasattr(kwargs["parsed_args"], "record_keys")
                            else kwargs["parsed_args"].avoid_record_keys
                        )
                        # 1 list element = str from quotes: get_virtual_entity_by_record_id 'REFERENCE 2012 customers 1001'
                        # Split it into a list
                        if len(record_keys) == 1:
                            record_keys = record_keys[0].split()

                        if len(record_keys) % 2 != 0:
                            print_error(f"Uneven number of data source codes and record IDs: {record_keys}")
                            return None

                        # Build the list of tuples expected by the SDK for record_keys arguments
                        # [('REFERENCE', '2012'), ('CUSTOMERS', '1001')]
                        kwargs["record_keys"] = [tuple(record_keys[i : i + 2]) for i in range(0, len(record_keys), 2)]

                    # If the command uses entity IDs perform clean up, sanity checks and build the expected list for the SDK
                    if hasattr(kwargs["parsed_args"], "entity_ids"):
                        entity_ids_str = kwargs["parsed_args"].entity_ids

                        # entity_list could be provided with commas, remove then '1,2,3,4' -> '1 2 3 4'
                        entity_ids_str = entity_ids_str.replace(",", " ")

                        # Convert back list for further checks and ready to send to the do_ method
                        entity_ids_list = entity_ids_str.split()
                        non_ints = [id for id in entity_ids_list if not id.isdigit()]
                        if non_ints:
                            print_error(f"Entity IDs should be integers: {non_ints}")
                            return None

                        # Convert the str digits to ints
                        kwargs["entity_ids"] = [int(i) for i in entity_ids_list]

                # Catch argument errors from parser.parse_args and display the commands help
                # Argparse parser error method is subclassed by SzCommandArgumentParser and displays the error
                except SystemExit:
                    self.do_help(do_method.__name__)
                    return None
                # Catch parsing errors such as missing single quote around JSON, the error is displayed by parse()
                except ValueError:
                    return None
                # Catch errors from methods such as get_engine_flags
                except (KeyError, SzError) as err:
                    print_error(err)
                    return None

            if self.timer:
                timer_start = time.perf_counter()

            # Run the decorated method passing back kwargs for use in API call
            try:
                result = do_method(self, **kwargs)
            except (SzError, IOError) as err:
                result = None
                print_error(err)
            finally:
                if self.timer:
                    exec_time = time.perf_counter() - timer_start
                    print_info(
                        f"Approximate execution time (s): {exec_time:.5f}",
                    )

                # TODO - Ant - Do these belong here or in post cmd?
                self.format_json_cmd = False
                self.color_json_cmd = False
                self.cmd_color = False
                self.cmd_format = False

            return result

        return wrapped_func

    return decorator


# -------------------------------------------------------------------------
# Classes
# -------------------------------------------------------------------------
class SzCommandArgumentParser(argparse.ArgumentParser):
    """Subclass ArgumentParser, override error() with custom message"""

    def error(self, message: str) -> NoReturn:
        self.exit(
            2,
            print_error(message),
        )


class SzCmdShell(cmd.Cmd):
    """Main Cmd class"""

    def __init__(
        self,
        engine_settings: str,
        cli_args: argparse.Namespace,
    ):
        super().__init__()

        self.cli_args = cli_args
        self.engine_settings = engine_settings

        # Acquire Senzing engines
        try:
            self.sz_factory = SzAbstractFactory(
                MODULE_NAME, self.engine_settings, verbose_logging=self.cli_args.debug_trace
            )
            self.sz_config = self.sz_factory.create_sz_config()
            self.sz_configmgr = self.sz_factory.create_sz_configmanager()
            self.sz_diagnostic = self.sz_factory.create_sz_diagnostic()
            self.sz_engine = self.sz_factory.create_sz_engine()
            self.sz_product = self.sz_factory.create_sz_product()
        except SzError as err:
            print_error(err)
            sys.exit(1)

        # TODO - Ant -  Move to helpers
        # Get Senzing engine flags for use in auto completion
        self.engine_flags_list = list(SzEngineFlags.__members__.keys())

        # Collect attributes from configuration
        self.attrs = self.get_sz_config_attrs()

        # Could be deprecated, undocumented, not supported, experimental or not relevant
        self.__hidden_cmds = (
            "do_EOF",
            "do_find_interesting_entities_by_entity_id",
            "do_find_interesting_entities_by_record_id",
            "do_get_redo_record",
            "do_get_feature",
            "do_help",
            "do_hidden",
            "do_shell",
        )

        # Session wide color disabled?
        self.color_disabled = self.cli_args.color_disable

        # Themes - set early, used for setting cmd prompt, use the default colors set by the terminal
        self.themes = Colors.AVAILABLE_THEMES
        self.theme = "TERMINAL"
        Colors.set_theme(self.theme)

        # Cmd module settings
        self.intro = ""
        self.prompt = colorize_cmd_prompt("szcmd", "info", self.color_disabled)
        # self.prompt = colorize_cmd_prompt("szcmd", "info", True)

        # Readline and history
        self.history_avail = False
        self.history_disable = self.cli_args.hist_disable
        self.history_msg = ""

        # Capture output
        self.capture_file = None

        # For pretty printing JSON responses
        self.cmd_color = False
        self.cmd_format = False
        self.color_json = True
        self.color_json_cmd = False
        self.format_json = False
        self.format_json_cmd = False

        # General
        self.last_response = ""
        self.scroll_output = False
        self.timer = False

        # Configuration ini file for this tool
        config_file_str = f"~/.{MODULE_NAME.lower()}{'.ini'}"
        self.config_file = pathlib.Path(config_file_str).expanduser()

        # Display can't read/write config message once, not at all in container
        self.config_error = False
        docker_launched = os.getenv("SENZING_DOCKER_LAUNCHED")
        self.docker_launched = True if docker_launched in ("y", "yes", "t", "true", "on", "1") else False

        # -------------------------------------------------------------------------
        # do_* method parsers
        # -------------------------------------------------------------------------

        # pylint: disable=invalid-name

        self.parser = SzCommandArgumentParser(
            add_help=False,
            prog=MODULE_NAME,
            usage=argparse.SUPPRESS,
        )
        self.subparsers = self.parser.add_subparsers()

        # szconfig parsers

        get_config_parser = self.subparsers.add_parser("get_config", usage=argparse.SUPPRESS)
        get_config_parser.add_argument("config_id", type=int)

        # szconfigmanager parsers

        replace_default_config_id_parser = self.subparsers.add_parser(
            "replace_default_config_id", usage=argparse.SUPPRESS
        )
        replace_default_config_id_parser.add_argument("current_default_config_id", type=int)
        replace_default_config_id_parser.add_argument("new_default_config_id", type=int)

        set_default_config_id_parser = self.subparsers.add_parser("set_default_config_id", usage=argparse.SUPPRESS)
        set_default_config_id_parser.add_argument("config_id", type=int)

        # szdiagnostic parsers

        check_datastore_performance_parser = self.subparsers.add_parser(
            "check_datastore_performance", usage=argparse.SUPPRESS
        )
        check_datastore_performance_parser.add_argument("seconds_to_run", default=3, nargs="?", type=int)

        get_feature_parser = self.subparsers.add_parser("get_feature", usage=argparse.SUPPRESS)
        get_feature_parser.add_argument("featureID", type=int)

        purge_repository_parser = self.subparsers.add_parser("purge_repository", usage=argparse.SUPPRESS)
        purge_repository_parser.add_argument(
            "-FORCEPURGE",
            "--FORCEPURGE",
            action="store_true",
            default=False,
            dest="force_purge",
            required=False,
        )

        # szengine parsers

        add_record_parser = self.subparsers.add_parser("add_record", usage=argparse.SUPPRESS)
        add_record_parser.add_argument("data_source_code")
        add_record_parser.add_argument("record_id")
        add_record_parser.add_argument("record_definition")
        add_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        delete_record_parser = self.subparsers.add_parser("delete_record", usage=argparse.SUPPRESS)
        delete_record_parser.add_argument("data_source_code")
        delete_record_parser.add_argument("record_id")
        delete_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        export_csv_entity_report_parser = self.subparsers.add_parser(
            "export_csv_entity_report", usage=argparse.SUPPRESS
        )
        export_csv_entity_report_parser.add_argument("output_file")
        export_csv_entity_report_parser.add_argument("-f", "--flags", nargs="+", required=False)
        export_csv_entity_report_parser.add_argument("-t", "--csv_column_list", required=False, type=str)

        export_json_entity_report_parser = self.subparsers.add_parser(
            "export_json_entity_report", usage=argparse.SUPPRESS
        )
        export_json_entity_report_parser.add_argument("output_file")
        export_json_entity_report_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_interesting_entities_by_entity_id_parser = self.subparsers.add_parser(
            "find_interesting_entities_by_entity_id", usage=argparse.SUPPRESS
        )
        find_interesting_entities_by_entity_id_parser.add_argument("entity_id", type=int)
        find_interesting_entities_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_interesting_entities_by_record_id_parser = self.subparsers.add_parser(
            "find_interesting_entities_by_record_id", usage=argparse.SUPPRESS
        )
        find_interesting_entities_by_record_id_parser.add_argument("data_source_code")
        find_interesting_entities_by_record_id_parser.add_argument("record_id")
        find_interesting_entities_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_network_by_entity_id_parser = self.subparsers.add_parser(
            "find_network_by_entity_id", usage=argparse.SUPPRESS
        )
        find_network_by_entity_id_parser.add_argument("entity_ids")
        find_network_by_entity_id_parser.add_argument("max_degrees", type=int)
        find_network_by_entity_id_parser.add_argument("build_out_degrees", type=int)
        find_network_by_entity_id_parser.add_argument("build_out_max_entities", type=int)
        find_network_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_network_by_record_id_parser = self.subparsers.add_parser(
            "find_network_by_record_id", usage=argparse.SUPPRESS
        )
        # find_network_by_record_id_parser.add_argument("record_keys", nargs="*")
        find_network_by_record_id_parser.add_argument("record_keys", nargs="+")
        find_network_by_record_id_parser.add_argument("max_degrees", type=int)
        find_network_by_record_id_parser.add_argument("build_out_degrees", type=int)
        find_network_by_record_id_parser.add_argument("build_out_max_entities", type=int)
        find_network_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_path_by_entity_id_parser = self.subparsers.add_parser("find_path_by_entity_id", usage=argparse.SUPPRESS)
        find_path_by_entity_id_parser.add_argument("start_entity_id", type=int)
        find_path_by_entity_id_parser.add_argument("end_entity_id", type=int)
        find_path_by_entity_id_parser.add_argument("max_degrees", type=int)
        # find_path_by_entity_id_parser.add_argument("-a", "--avoid_entity_ids", default="", nargs="?", required=False)
        find_path_by_entity_id_parser.add_argument(
            "-a", "--avoid_entity_ids", default=[], nargs="+", required=False, type=int
        )
        find_path_by_entity_id_parser.add_argument(
            # "-r", "--required_data_sources", default="", nargs="?", required=False
            "-r",
            "--required_data_sources",
            default=[],
            nargs="+",
            required=False,
        )
        find_path_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_path_by_record_id_parser = self.subparsers.add_parser("find_path_by_record_id", usage=argparse.SUPPRESS)
        find_path_by_record_id_parser.add_argument("start_data_source_code")
        find_path_by_record_id_parser.add_argument("start_record_id")
        find_path_by_record_id_parser.add_argument("end_data_source_code")
        find_path_by_record_id_parser.add_argument("end_record_id")
        find_path_by_record_id_parser.add_argument("max_degrees", type=int)
        # find_path_by_record_id_parser.add_argument("-a", "--avoid_record_keys", default="", nargs="?", required=False)
        find_path_by_record_id_parser.add_argument("-a", "--avoid_record_keys", default=[], nargs="+", required=False)
        # find_path_by_record_id_parser.add_argument("-r", "--required_data_sources", default="", nargs="?", required=False)
        find_path_by_record_id_parser.add_argument(
            "-r", "--required_data_sources", default=[], nargs="+", required=False
        )
        find_path_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_entity_by_entity_id_parser = self.subparsers.add_parser("get_entity_by_entity_id", usage=argparse.SUPPRESS)
        get_entity_by_entity_id_parser.add_argument("entity_id", type=int)
        get_entity_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_entity_by_record_id_parser = self.subparsers.add_parser("get_entity_by_record_id", usage=argparse.SUPPRESS)
        get_entity_by_record_id_parser.add_argument("data_source_code")
        get_entity_by_record_id_parser.add_argument("record_id")
        get_entity_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_record_parser = self.subparsers.add_parser("get_record", usage=argparse.SUPPRESS)
        get_record_parser.add_argument("data_source_code")
        get_record_parser.add_argument("record_id")
        get_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_virtual_entity_by_record_id_parser = self.subparsers.add_parser(
            "get_virtual_entity_by_record_id", usage=argparse.SUPPRESS
        )
        get_virtual_entity_by_record_id_parser.add_argument("record_keys", nargs="+")
        get_virtual_entity_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        how_entity_by_entity_id_parser = self.subparsers.add_parser("how_entity_by_entity_id", usage=argparse.SUPPRESS)
        how_entity_by_entity_id_parser.add_argument("entity_id", type=int)
        how_entity_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        preprocess_record_parser = self.subparsers.add_parser("preprocess_record", usage=argparse.SUPPRESS)
        preprocess_record_parser.add_argument("record_definition")
        preprocess_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        process_redo_record_parser = self.subparsers.add_parser("process_redo_record", usage=argparse.SUPPRESS)
        process_redo_record_parser.add_argument("redo_record")
        process_redo_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        reevaluate_entity_parser = self.subparsers.add_parser("reevaluate_entity", usage=argparse.SUPPRESS)
        reevaluate_entity_parser.add_argument("entity_id", type=int)
        reevaluate_entity_parser.add_argument("-f", "--flags", nargs="+", required=False)

        reevaluate_record_parser = self.subparsers.add_parser("reevaluate_record", usage=argparse.SUPPRESS)
        reevaluate_record_parser.add_argument("data_source_code")
        reevaluate_record_parser.add_argument("record_id")
        reevaluate_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        search_by_attributes_parser = self.subparsers.add_parser("search_by_attributes", usage=argparse.SUPPRESS)
        search_by_attributes_parser.add_argument("attributes")
        search_by_attributes_parser.add_argument("search_profile", default="SEARCH", nargs="?")
        search_by_attributes_parser.add_argument("-f", "--flags", nargs="+", required=False)

        why_entities_parser = self.subparsers.add_parser("why_entities", usage=argparse.SUPPRESS)
        why_entities_parser.add_argument("entity_id_1", type=int)
        why_entities_parser.add_argument("entity_id_2", type=int)
        why_entities_parser.add_argument("-f", "--flags", nargs="+", required=False)

        why_record_in_entity_parser = self.subparsers.add_parser("why_record_in_entity", usage=argparse.SUPPRESS)
        why_record_in_entity_parser.add_argument("data_source_code")
        why_record_in_entity_parser.add_argument("record_id")
        why_record_in_entity_parser.add_argument("-f", "--flags", nargs="+", required=False)

        why_records_parser = self.subparsers.add_parser("why_records", usage=argparse.SUPPRESS)
        why_records_parser.add_argument("data_source_code_1")
        why_records_parser.add_argument("record_id_1")
        why_records_parser.add_argument("data_source_code_2")
        why_records_parser.add_argument("record_id_2")
        why_records_parser.add_argument("-f", "--flags", nargs="+", required=False)

        # Utility parsers

        response_to_file_parser = self.subparsers.add_parser("response_to_file", usage=argparse.SUPPRESS)
        response_to_file_parser.add_argument("file_path")

        set_theme_parser = self.subparsers.add_parser("set_theme", usage=argparse.SUPPRESS)
        set_theme_parser.add_argument(
            "theme",
            choices=self.themes,
            nargs=1,
        )

    # pylint: enable=invalid-name

    def get_sz_config_attrs(self) -> List[str]:
        # TODO - Work in progress for JSON autocomplete
        # TODO - Ant - Move to __init__ / post_cmd and only get once and then reinit if config changes from methods like replace_default_config_id
        config_id = self.sz_engine.get_active_config_id()
        config = self.sz_configmgr.get_config(config_id)
        config_json = json.loads(config)
        cfg_attr = config_json["G2_CONFIG"]["CFG_ATTR"]
        attr_list = []
        # TODO - Ant - comprehension
        for attr in cfg_attr:
            # print(attr["ATTR_CODE"] + "-" + attr["INTERNAL"])
            if attr["INTERNAL"].lower() == "no":
                attr_list.append(attr["ATTR_CODE"])

        return attr_list

    # Call helper function to format and print command responses with constant values
    def output_response(self, response: Union[int, str], color: str = "") -> str:
        formatted_response: str = print_response(
            response,
            self.color_json,
            self.color_json_cmd,
            self.format_json,
            self.format_json_cmd,
            self.cmd_color,
            self.cmd_format,
            self.scroll_output,
            color,
            self.color_disabled,
        )

        return formatted_response

    # -------------------------------------------------------------------------
    # Cmd module methods
    # -------------------------------------------------------------------------

    # Override function from cmd module to make command completion case-insensitive
    def completenames(self, text: str, *ignored: Any) -> List[str]:
        do_text = "do_" + text
        return [a[3:] for a in self.get_names() if a.lower().startswith(do_text.lower())]

    def do_exit(self, _) -> bool:  # type: ignore[no-untyped-def]
        self.do_quit(_)
        return True

    @staticmethod
    def do_quit(_) -> bool:  # type: ignore[no-untyped-def]  # pylint: disable=unused-argument
        return True

    def do_shell(self, line: str) -> None:
        do_shell(self, line)

    # Handle unknown commands
    def default(self, line: str) -> None:
        print_warning("Unknown command, type help or ?")

    # Do nothing if line is empty
    def emptyline(self) -> bool:
        return False

    # Override in cmd module to return methods for autocomplete and help
    # ignoring any hidden commands
    def get_names(self, include_hidden: bool = False) -> List[str]:
        if not include_hidden:
            return [n for n in dir(self.__class__) if n not in self.__hidden_cmds]

        return list(dir(self.__class__))

    def postcmd(self, stop: bool, line: str) -> bool:
        if self.capture_file and self.last_response:
            self.capture_file.write(f"{self.prompt}{line}\n\n")
            self.capture_file.write(f"{self.last_response}\n\n")
            self.capture_file.flush()

        return cmd.Cmd.postcmd(self, stop, line)

    def postloop(self) -> None:
        if self.capture_file:
            self.capture_file.close()

    def precmd(self, line: str) -> str:
        return line

    def preloop(self) -> None:
        # TODO - Ant - Should only be used if in interactive mode not commands or file
        if self.cli_args.capture_file:
            with suppress(IOError):
                self.capture_file = capture_file(self.cli_args.capture_file)

        if not self.history_disable:
            history_check = history_setup()
            # Non-empty string means error and msg was returned
            if history_check:
                print_warning(history_check)

        # Check if there is a config file and use config
        if not self.docker_launched:
            self.read_config()
            # TODO - Ant - This isn't needed? read_config() will try and create a new one
            self.write_config()

        print_info(f"Welcome to {MODULE_NAME}. Type help or ? for help", color_disabled=self.color_disabled)

    # -------------------------------------------------------------------------
    # Non-interactive input methods
    # -------------------------------------------------------------------------

    def commands_from_cli(self, commands: List[List[str]]) -> None:
        """
        Run command(s) from the command line, here could be multiple commands and associated arguments in
        commands[]. Command formatters (jsonl, json, etc) are permitted and are handled by sz_cmds_decorator
        """
        number_of_commands = len(commands)
        for each_cmd in commands:
            requested_cmd = each_cmd[0]

            # Build a new list without the requested command resulting in any arguments for the command
            # Due to the way argparse builds the list with the -C argument, also repr() a list item (command argument)
            # if it looks like JSON otherwise the single quotes around the JSON are lost and characters such as space
            # in the JSON string break parsing in the do_* methods
            requested_args = [
                repr(i) if i.strip().startswith("{") and i.strip().endswith("}") else i
                for i in each_cmd
                if i != requested_cmd
            ]

            # Turn the arguments back into a single string for further parsing and call the requested command
            try:
                if number_of_commands > 1:
                    print(f"\n----- {' '.join(each_cmd)} -----")
                cmd_args = " ".join(requested_args)
                self.onecmd(f"{requested_cmd} {cmd_args}")
            except (ValueError, TypeError) as err:
                print_error(f"Problem with command: {err}")

    def commands_from_file(self, file_name: str) -> None:
        """
        Read commands from a file and call the matching commands. Command formatters (jsonl, json, etc) are
        permitted and are handled by sz_cmds_decorator
        """
        try:
            with open(file_name, encoding="utf-8") as cmds_file:
                for each_cmd in cmds_file:
                    each_cmd = each_cmd.strip()

                    # Skip blank lines and comment prefixes
                    if not each_cmd or each_cmd[0:1] in ("#", "-", "/"):
                        continue

                    (requested_cmd, *requested_args) = each_cmd.split()

                    try:
                        cmd_args = " ".join(requested_args)
                        print(f"\n----- {each_cmd} -----")
                        self.onecmd(f"{requested_cmd} {cmd_args}")
                    except (ValueError, TypeError) as err:
                        print_error(f"Problem with command: {err}")
        except OSError as err:
            print_error(err)

    # -------------------------------------------------------------------------
    # Custom help
    # -------------------------------------------------------------------------

    def do_help(self, arg: str = "") -> None:
        do_help(self, arg)

    def help_all(self) -> None:
        self.do_help()

    # TODO - Ant - Check this
    @staticmethod
    def help_overview() -> None:
        print(
            textwrap.dedent(
                f"""
        {colorize_str('This utility allows you to interact with the Senzing APIs.', 'dim')}

        {colorize_str('Help', 'highlight2')}
            {colorize_str('- View help for a command:', 'dim')} help COMMAND
            {colorize_str('- View all commands:', 'dim')} help all

        {colorize_str('Tab Completion', 'highlight2')}
            {colorize_str('- Tab completion is available for commands, files and engine flags', 'dim')}
            {colorize_str('- Hit tab on a blank line to see all commands', 'dim')}

        {colorize_str('JSON Formatting', 'highlight2')}
            {colorize_str('- Change JSON formatting by adding "json" or "jsonl" to the end of a command', 'dim')}
                - get_entity_by_entity_id 1001 jsonl

            {colorize_str('- Can be combined with color formatting options', 'dim')}
                - get_entity_by_entity_id 1001 jsonl nocolor

            {colorize_str('- Set the JSON format for the session, saves the preference to a configuration file for use across sessions', 'dim')}
            {colorize_str('- Specifying the JSON and color formatting options at the end of a command override this setting for that command', 'dim')}
                - setOutputFormat json|jsonl

            {colorize_str('- Convert last response output between json and jsonl', 'dim')}
                - response_reformat_json

        {colorize_str('Color Formatting', 'highlight2')}
            {colorize_str('- Add or remove colors from JSON formatting by adding "color", "colour", "nocolor" or "nocolour" to the end of a command', 'dim')}
                - get_entity_by_entity_id 1001 color

            {colorize_str('- Can be combined with JSON formatting options', 'dim')}
                - get_entity_by_entity_id 1001 color jsonl

            {colorize_str('- Set the color formatting for the session, saves the preference to a configuration file for use across sessions', 'dim')}
            {colorize_str('- Specifying the JSON and color formatting options at the end of a command override this setting for that command', 'dim')}
                - setOutputColor color|colour|nocolor|nocolour

        {colorize_str('Capturing Output', 'highlight2')}
            {colorize_str('- Capture the last response output to a file or the clipboard', 'dim')}
                - response_to_clipboard
                - response_to_file /tmp/myoutput.json
            {colorize_str('- response_to_clipboard does not work in containers or SSH sessions', 'dim')}

        {colorize_str('History', 'highlight2')}
            {colorize_str('- Arrow keys to cycle through history of commands', 'dim')}
            {colorize_str('- Ctrl-r can be used to search history', 'dim')}
            {colorize_str('- Display history:', 'dim')} history

        {colorize_str('Timer', 'highlight2')}
            {colorize_str('- Toggle on/off approximate time a command takes to complete', 'dim')}
            {colorize_str('- Turn off JSON formatting and color output for higher accuracy', 'dim')}
                - timer

        {colorize_str('Shell', 'highlight2')}
            {colorize_str('- Run basic OS shell commands', 'dim')}
                - ! ls

        {colorize_str('Support', 'highlight2')}
            {colorize_str('- Senzing Support:', 'dim')} {colorize_str('https://senzing.zendesk.com/hc/en-us/requests/new', 'highlight1,underline')}
            {colorize_str('- Senzing Knowledge Center:', 'dim')} {colorize_str('https://senzing.zendesk.com/hc/en-us', 'highlight1,underline')}
            {colorize_str('- API Docs:', 'dim')} {colorize_str('https://docs.senzing.com', 'highlight1,underline')}

        """
            )
        )

    # -----------------------------------------------------------------------------
    # szconfig commands
    # -----------------------------------------------------------------------------

    @sz_cmds_decorator(cmd_has_args=False)
    def do_get_template_config(self) -> None:
        """
        Get a template configuration

        Syntax:
            get_template_config

        """

        config_handle = self.sz_config.create_config()
        response = self.sz_config.export_config(config_handle)
        self.sz_config.close_config(config_handle)
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # szconfigmanager commands
    # -----------------------------------------------------------------------------

    @sz_cmds_decorator()
    def do_get_config(self, **kwargs: Any) -> None:
        """
        Get a configuration

        Syntax:
            get_config config_id

        Example:
            get_config 4180061352

        Arguments:
            config_id = Configuration identifier

        Notes:
            - Retrieve the active configuration identifier with get_active_config_id

            - Retrieve a list of configurations and identifiers with get_configs"""

        response = self.sz_configmgr.get_config(kwargs["parsed_args"].config_id)
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_get_configs(self) -> None:
        """
        Get a list of current configurations

        Syntax:
            get_configs"""

        response = self.sz_configmgr.get_configs()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_get_default_config_id(self) -> None:
        """
        Get the default configuration ID

        Syntax:
            get_default_config_id"""

        response = self.sz_configmgr.get_default_config_id()
        self.last_response = self.output_response(response, "success")

    @sz_cmds_decorator()
    def do_replace_default_config_id(self, **kwargs: Any) -> None:
        """
        Replace the default configuration ID

        Syntax:
            replace_default_config_id current_default_config_id new_default_config_id

        Example:
            replace_default_config_id 4180061352 2787925967

        Arguments:
            current_default_config_id = Configuration identifier
            new_default_config_id = Configuration identifier

        Notes:
            - Retrieve a list of configurations and identifiers with get_configs"""

        self.sz_configmgr.replace_default_config_id(
            kwargs["parsed_args"].current_default_config_id,
            kwargs["parsed_args"].new_default_config_id,
        )
        self.output_response("New default config set, reinitializing...", "success")
        self.sz_factory.reinitialize(kwargs["parsed_args"].new_default_config_id)

        # Configuration has changed, update attributes from configuration
        self.attrs = self.get_sz_config_attrs()
        # TODO Test this, resetting last_response in pre/-cmd
        # self.last_response = ""

    @sz_cmds_decorator()
    def do_set_default_config_id(self, **kwargs: Any) -> None:
        """
        Set the default configuration ID

        Syntax:
            set_default_config_id config_id

        Example:
            set_default_config_id 4180061352

        Arguments:
            config_id = Configuration identifier

        Notes:
            - Retrieve a list of configurations and identifiers with get_configList"""

        self.sz_configmgr.set_default_config_id(kwargs["parsed_args"].config_id)
        # TODO - Ant - reinit
        self.output_response("Default config set, reinitializing...", "success")
        # Configuration has changed, update attributes from configuration
        self.attrs = self.get_sz_config_attrs()
        # self.last_response = ""

    # -----------------------------------------------------------------------------
    # szdiagnostic commands
    # -----------------------------------------------------------------------------

    @sz_cmds_decorator()
    def do_check_datastore_performance(self, **kwargs: Any) -> None:
        """
        Run a performance check on the database

        Syntax:
            check_datastore_performance [seconds_to_run]
            check_datastore_performance

        Arguments:
            seconds_to_run = Time in seconds to run the check, default is 3"""

        response = self.sz_diagnostic.check_datastore_performance(kwargs["parsed_args"].seconds_to_run)
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_get_datastore_info(self) -> None:
        """
        Get data store information

        Syntax:
            get_datastore_info"""

        response = self.sz_diagnostic.get_datastore_info()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_get_feature(self, **kwargs: Any) -> None:
        """
        Get feature information

        Syntax:
            get_feature feature_id

        Examples:
            get_feature 1

        Arguments:
            feature_id = Identifier of feature"""

        response = self.sz_diagnostic.get_feature(kwargs["parsed_args"].featureID)
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_purge_repository(self, **kwargs: Any) -> None:
        """
        Purge Senzing database of all data

        Syntax:
            purge_repository [--FORCEPURGE]

        Example:
            purge_repository

        Arguments:
            --FORCEPURGE = Don't prompt before purging. USE WITH CAUTION!

        Caution:
            - This deletes all data in the Senzing database!"""

        purge_msg = colorize_output(
            textwrap.dedent(
                """

                ********** WARNING **********

                This will purge all currently loaded data from the senzing database!
                Before proceeding, all instances of senzing (custom code, rest api, redoer, etc.) must be shut down.

                ********** WARNING **********

                Are you sure you want to purge the Senzing database? Type YESPURGESENZING to purge: """
            ),
            "warning",
        )

        if not kwargs["parsed_args"].force_purge:
            if input(purge_msg) != "YESPURGESENZING":
                print("\nSenzing repository not purged\n")
                return

        self.sz_diagnostic.purge_repository()
        # TODO Test this, resetting last_response in pre/-cmd
        # self.last_response = ""
        print("\nSenzing repository purged\n")

    # -----------------------------------------------------------------------------
    # szengine commands
    # -----------------------------------------------------------------------------

    @sz_cmds_decorator()
    def do_add_record(self, **kwargs: Any) -> None:
        """
        Add a record and optionally return information

        Syntax:
            add_record dsrc_source_code record_id record_definition [-f flag ...]

        Examples:
            add_record test 1 '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}'
            add_record test 1 '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}' -f SZ_WITH_INFO

        Arguments:
            dsrc_source_code = Data source code
            record_id = Record identifier
            record_definition = Senzing mapped JSON representation of a record
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """
        add_record = functools.partial(
            self.sz_engine.add_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
            kwargs["parsed_args"].record_definition,
        )

        response = add_record(kwargs["flags"]) if "flags" in kwargs else add_record()

        if response == "{}":
            self.last_response = self.output_response("Record added", "success")
        else:
            self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_count_redo_records(self) -> None:
        """
        Counts the number of records in the redo queue

        Syntax:
            count_redo_records"""

        response = self.sz_engine.count_redo_records()
        if not response:
            self.last_response = self.output_response("No redo records", "info")
        else:
            self.last_response = self.output_response(response, "success")

    @sz_cmds_decorator()
    def do_delete_record(self, **kwargs: Any) -> None:
        """
        Delete a record and optionally return information

        Syntax:
            delete_record data_source_code record_id [-f flag ...]

        Examples:
            delete_record test 1
            delete_record test 1 -f SZ_WITH_INFO

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        delete_record = functools.partial(
            self.sz_engine.delete_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = delete_record(kwargs["flags"]) if "flags" in kwargs else delete_record()

        if response == "{}":
            self.last_response = self.output_response("Record deleted.", "success")
        else:
            self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_export_csv_entity_report(self, **kwargs: Any) -> None:
        """
        Export repository contents as CSV

        Syntax:
            export_csv_entity_report output_file [-t csv_column_list,...] [-f flag ...]

        Examples:
            export_csv_entity_report export.csv
            export_csv_entity_report export.csv -t RESOLVED_ENTITY_ID,RELATED_ENTITY_ID,MATCH_LEVEL,MATCH_KEY,DATA_SOURCE,RECORD_ID
            export_csv_entity_report export.csv -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_EXPORT_INCLUDE_ALL_ENTITIES

        Arguments:
            output_file = File to save export to
            csv_column_list = Comma separated list of output columns (don't specify for defaults)
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Available csv_column_list columns
                - RESOLVED_ENTITY_ID,RELATED_ENTITY_ID,MATCH_LEVEL,MATCH_KEY,DATA_SOURCE,RECORD_ID,RESOLVED_ENTITY_NAME,ERRULE_CODE,JSON_DATA

            - Engine flag details https://docs.senzing.com/flags/index.html

        Caution:
            - Export isn't intended for exporting large numbers of entities and associated data source record information.
              Beyond 100M+ data source records isn't suggested. For exporting overview entity and relationship data for
              analytical purposes outside of Senzing please review the following article.

              https://senzing.zendesk.com/hc/en-us/articles/360010716274--Advanced-Replicating-the-Senzing-results-to-a-Data-Warehouse
        """
        rec_cnt = 0

        export_csv = functools.partial(
            self.sz_engine.export_csv_entity_report,
            kwargs["parsed_args"].csv_column_list,
        )

        try:
            export_handle = export_csv(kwargs["flags"]) if "flags" in kwargs else export_csv()

            with open(kwargs["parsed_args"].output_file, "w", encoding="utf-8") as csv_out:
                while True:
                    export_record = self.sz_engine.fetch_next(export_handle)
                    if not export_record:
                        break
                    csv_out.write(export_record)
                    rec_cnt += 1
                    if rec_cnt % 1000 == 0:
                        print(f"Exported {rec_cnt} records...", flush=True)
                self.sz_engine.close_export(export_handle)
        except (SzError, IOError) as err:
            print_error(err)
        else:
            self.output_response(f"Total exported records: {rec_cnt}", "success")
            # self.last_response = ""

    @sz_cmds_decorator()
    def do_export_json_entity_report(self, **kwargs: Any) -> None:
        """
        Export repository contents as JSON

        Syntax:
            export_json_entity_report output_file [-f flag ...]

        Examples:
            export_json_entity_report export.json
            export_json_entity_report export.json -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_EXPORT_INCLUDE_ALL_ENTITIES

        Arguments:
            output_file = File to save export to
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html

        Caution:
            - Export isn't intended for exporting large numbers of entities and associated data source record information.
              Beyond 100M+ data source records isn't suggested. For exporting overview entity and relationship data for
              analytical purposes outside of Senzing please review the following article.

              https://senzing.zendesk.com/hc/en-us/articles/360010716274--Advanced-Replicating-the-Senzing-results-to-a-Data-Warehouse
        """

        rec_cnt = 0

        export_json = functools.partial(
            self.sz_engine.export_json_entity_report,
        )

        try:
            export_handle = export_json(kwargs["flags"]) if "flags" in kwargs else export_json()
            with open(kwargs["parsed_args"].output_file, "w", encoding="utf-8") as data_out:
                while True:
                    export_record = self.sz_engine.fetch_next(export_handle)
                    if not export_record:
                        break
                    data_out.write(export_record)
                    rec_cnt += 1
                    if rec_cnt % 1000 == 0:
                        print(f"Exported {rec_cnt} records...", flush=True)
                self.sz_engine.close_export(export_handle)
        except (SzError, IOError) as err:
            print_error(err)
        else:
            self.output_response(f"Total exported records: {rec_cnt}", "success")
            # self.last_response = ""

    @sz_cmds_decorator()
    def do_find_interesting_entities_by_entity_id(self, **kwargs: Any) -> None:
        """
        Find interesting entities close to an entity by resolved entity identifier

        Syntax:
            find_interesting_entities_by_entity_id entity_id [-f flag ...]

        Example:
            find_interesting_entities_by_entity_id 1

        Arguments:
            entity_id = Identifier for an entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html

            - Experimental feature requires additional configuration, contact support@senzing.com
        """

        find_interesting_entities_by_entity_id = functools.partial(
            self.sz_engine.find_interesting_entities_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = (
            find_interesting_entities_by_entity_id(kwargs["flags"])
            if "flags" in kwargs
            else find_interesting_entities_by_entity_id()
        )

        # TODO - Ant -
        # if "flags" in kwargs:
        #     response = self.sz_engine.find_interesting_entities_by_entity_id(
        #         kwargs["parsed_args"].entity_id, kwargs["flags"]
        #     )
        # else:
        #     response = self.sz_engine.find_interesting_entities_by_entity_id(kwargs["parsed_args"].entity_id)

        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_find_interesting_entities_by_record_id(self, **kwargs: Any) -> None:
        """
        Find interesting entities close to an entity by record identifier

        Syntax:
            find_interesting_entities_by_record_id data_source_code record_id [-f flag ...]

        Example:
            find_interesting_entities_by_record_id customers 1001

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html

            - Experimental feature requires additional configuration, contact support@senzing.com
        """

        if "flags" in kwargs:
            response = self.sz_engine.find_interesting_entities_by_record_id(
                kwargs["parsed_args"].data_source_code,
                kwargs["parsed_args"].record_id,
                kwargs["flags"],
            )
        else:
            response = self.sz_engine.find_interesting_entities_by_record_id(
                kwargs["parsed_args"].data_source_code,
                kwargs["parsed_args"].record_id,
            )

        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_find_network_by_entity_id(self, **kwargs: Any) -> None:
        """
        Find network between entities

        Syntax:
            find_network_by_entity_id entity_ids max_degrees build_out_degrees build_out_max_entities [-f flag ...]

        Example:
            find_network_by_entity_id '1 6 9' 4 3 20

        Arguments:
            entity_ids = List of entities to find paths between and networks around (NOTE: quotes around ENTITY_IDS)
            max_degrees = Maximum number of relationships to search for a path
            build_out_degrees = Maximum degree of relationships to include around each entity
            build_out_max_entities = Maximum number of entities to return
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.find_network_by_entity_id(
                kwargs["entity_ids"],
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].build_out_degrees,
                kwargs["parsed_args"].build_out_max_entities,
                kwargs["flags"],
            )
        else:
            response = self.sz_engine.find_network_by_entity_id(
                kwargs["entity_ids"],
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].build_out_degrees,
                kwargs["parsed_args"].build_out_max_entities,
            )

        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_find_network_by_record_id(self, **kwargs: Any) -> None:
        """
        Find network between records

        Syntax:
            find_network_by_record_id record_keys max_degrees build_out_degrees build_out_max_entities [-f flag ...]

        Example:
            find_network_by_record_id 'REFERENCE 2012 CUSTOMERS 1001' 6 4 15

        Arguments:
            record_keys = List of datasource codes and record ID pairs to find paths between and networks around (NOTE: quotes around RECORD_KEYS)
            max_degrees = Maximum number of relationships to search for a path
            build_out_degrees = Maximum degree of relationships to include around each entity
            build_out_max_entities = Maximum number of entities to return
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.find_network_by_record_id(
                kwargs["record_keys"],
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].build_out_degrees,
                kwargs["parsed_args"].build_out_max_entities,
                kwargs["flags"],
            )
        else:
            response = self.sz_engine.find_network_by_record_id(
                kwargs["record_keys"],
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].build_out_degrees,
                kwargs["parsed_args"].build_out_max_entities,
            )

        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_find_path_by_entity_id(self, **kwargs: Any) -> None:
        """
        Find a path between two entities

        Syntax:
            find_path_by_entity_id start_entity_id end_entity_id max_degrees [-a avoid_entity_ids] [-r required_data_sources] [-f flag ...]

        Example:
            find_path_by_entity_id 100002 5 3
            find_path_by_entity_id 100002 5 3 -a 259 10
            find_path_by_entity_id 100002 5 3 -a 259 10 -r WATCHLIST

        Arguments:
            start_entity_id = Identifier for an entity
            end_entity_id = Identifier for an entity
            max_degrees = Maximum number of relationships to search for a path
            avoid_entity_ids = Space separated list of entity ID(s) to avoid when finding the path, default is no avoidance
            required_data_sources = Space separated list of data source(s) an entity on the path should have, default is no required data sources
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.find_path_by_entity_id(
                kwargs["parsed_args"].start_entity_id,
                kwargs["parsed_args"].end_entity_id,
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].avoid_entity_ids,
                kwargs["parsed_args"].required_data_sources,
                kwargs["flags"],
            )
        else:
            response = self.sz_engine.find_path_by_entity_id(
                kwargs["parsed_args"].start_entity_id,
                kwargs["parsed_args"].end_entity_id,
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].avoid_entity_ids,
                kwargs["parsed_args"].required_data_sources,
            )

        self.last_response = self.output_response(response)

    # TODO Wording on exclusions
    @sz_cmds_decorator()
    def do_find_path_by_record_id(self, **kwargs: Any) -> None:
        """
        Find a path between two records

        Syntax:
            find_path_by_record_id start_dsrc_code start_record_id end_dsrc_code end_record_id max_degrees [-a avoid_record_keys] [-r required_data_sources] [-f flag ...]

        Example:
            find_path_by_record_id reference 2141 reference 2121 6

        Arguments:
            start_dsrc_code = Data source code
            start_record_id = Record identifier
            end_dsrc_code = Data source code
            end_record_id = Record identifier
            max_degrees = Maximum number of relationships to search for a path
            avoid_record_keys = Space separated list of data source code and record IDs to avoid when finding the path, default is no avoidance
            required_data_sources = Space separated list of data source(s) an entity on the path should have, default is no required data sources
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.find_path_by_record_id(
                kwargs["parsed_args"].start_data_source_code,
                kwargs["parsed_args"].start_record_id,
                kwargs["parsed_args"].end_data_source_code,
                kwargs["parsed_args"].end_record_id,
                kwargs["parsed_args"].max_degrees,
                # Although the SDK and parser argument is avoid_record_keys, the sz_cmds_decorator detects
                # avoid_record_keys but always adds record_keys back to kwargs
                kwargs["record_keys"],
                kwargs["parsed_args"].required_data_sources,
                kwargs["flags"],
            )
        else:
            response = self.sz_engine.find_path_by_record_id(
                kwargs["parsed_args"].start_data_source_code,
                kwargs["parsed_args"].start_record_id,
                kwargs["parsed_args"].end_data_source_code,
                kwargs["parsed_args"].end_record_id,
                kwargs["parsed_args"].max_degrees,
                # Although the SDK and parser argument is avoid_record_keys, the sz_cmds_decorator detects
                # avoid_record_keys but always adds record_keys back to kwargs
                kwargs["record_keys"],
                kwargs["parsed_args"].required_data_sources,
            )

        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_get_active_config_id(self) -> None:
        """
        Get the active configuration identifier

        Syntax:
            get_active_config_id"""

        response = self.sz_engine.get_active_config_id()
        self.last_response = self.output_response(response, color="success")

    @sz_cmds_decorator()
    def do_get_entity_by_entity_id(self, **kwargs: Any) -> None:
        """
        Get entity by resolved entity identifier

        Syntax:
            get_entity_by_entity_id entity_id [-f flag ...]

        Examples:
            get_entity_by_entity_id 1
            get_entity_by_entity_id 1 -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_SUMMARY

        Arguments:
            entity_id = Identifier for an entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_entity = functools.partial(
            self.sz_engine.get_entity_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = get_entity(kwargs["flags"]) if "flags" in kwargs else get_entity()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_get_entity_by_record_id(self, **kwargs: Any) -> None:
        """
        Get entity by data source code and record identifier

        Syntax:
            get_entity_by_record_id data_source_code record_id [-f flag ...]

        Examples:
        get_entity_by_record_id customers 1001
        get_entity_by_record_id customers 1001 -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_SUMMARY

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_entity = functools.partial(
            self.sz_engine.get_entity_by_record_id,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = get_entity(kwargs["flags"]) if "flags" in kwargs else get_entity()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_get_record(self, **kwargs: Any) -> None:
        """
        Get a record

        Syntax:
            get_record data_source_code record_id [-f flag ...]

        Examples:
            get_record watchlist 2092
            get_record watchlist 2092 -f SZ_RECORD_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_FORMATTED_DATA

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_record = functools.partial(
            self.sz_engine.get_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = get_record(kwargs["flags"]) if "flags" in kwargs else get_record()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_get_redo_record(self) -> None:
        """
        Get a redo record from the redo queue

        Syntax:
            get_redo_record"""

        response = self.sz_engine.get_redo_record()
        if not response:
            self.last_response = self.output_response("No redo records.", "info")
        else:
            self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_get_stats(self) -> None:
        """
        Get engine workload statistics for last process

        Syntax:
            get_stats"""

        response = self.sz_engine.get_stats()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_get_virtual_entity_by_record_id(self, **kwargs: Any) -> None:
        """
        Determine how an entity composed of a given set of records would look

        Syntax:
            get_virtual_entity_by_record_id record_keys [-f FLAG ...]

        Example:
            get_virtual_entity_by_record_id 'REFERENCE 2071 CUSTOMERS 1069'

        Arguments:
            record_keys = List of datasource codes and record ID pairs to find paths between and networks around (NOTE: quotes around RECORD_KEYS)
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_virtual = functools.partial(
            self.sz_engine.get_virtual_entity_by_record_id,
            kwargs["record_keys"],
        )

        response = get_virtual(kwargs["flags"]) if "flags" in kwargs else get_virtual()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_how_entity_by_entity_id(self, **kwargs: Any) -> None:
        """
        Retrieve information on how entities are constructed from their records

        Syntax:
            how_entity_by_entity_id entity_id [-f flag ...]

        Example:
            how_entity_by_entity_id 96

        Arguments:
            entity_id = Identifier for an entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        how_entity = functools.partial(
            self.sz_engine.how_entity_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = how_entity(kwargs["flags"]) if "flags" in kwargs else how_entity()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_prime_engine(self) -> None:
        """
        Prime the Senzing engine

        Syntax:
            prime_engine"""

        self.sz_engine.prime_engine()
        self.last_response = self.output_response("Engine primed.", "success")

    @sz_cmds_decorator(cmd_has_args=True)
    def do_process_redo_record(self, **kwargs: Any) -> None:
        """
        Process a redo record fetched from the redo queue

        Syntax:
            process_redo_record redo_record [-f FLAG ...]

        Examples:
            process_redo_record <redo_record>
            process_redo_record <redo_record> -f SZ_WITH_INFO

        Arguments:
            redo_record = A redo record
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        process_redo = functools.partial(
            self.sz_engine.process_redo_record,
            kwargs["parsed_args"].redo_record,
        )

        response = process_redo(kwargs["flags"]) if "flags" in kwargs else process_redo()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=True)
    def do_preprocess_record(self, **kwargs: Any) -> None:
        """
        Pre-process a record

        Syntax:
            preprocess_record record_definition [-f flag ...]

        Examples:
            preprocess_record '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}'
            preprocess_record '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}' -f SZ_RECORD_DEFAULT_FLAGS

        Arguments:
            record_definition = Senzing mapped JSON representation of a record
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        preprocess_record = functools.partial(
            self.sz_engine.preprocess_record,
            kwargs["parsed_args"].record_definition,
        )

        response = preprocess_record(kwargs["flags"]) if "flags" in kwargs else preprocess_record()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_reevaluate_entity(self, **kwargs: Any) -> None:
        """
        Reevaluate an entity and optionally return information

        Syntax:
            reevaluate_entity entity_id [-f FLAG ...]

        Example:
            reevaluate_entity 1

            reevaluate_entity 1 -f SZ_WITH_INFO

        Arguments:
            entity_id = Entity identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        reevaluate = functools.partial(
            self.sz_engine.reevaluate_entity,
            kwargs["parsed_args"].entity_id,
        )

        response = reevaluate(kwargs["flags"]) if "flags" in kwargs else reevaluate()
        if response == "{}":
            self.last_response = self.output_response("Entity reevaluated", "success")
        else:
            self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_reevaluate_record(self, **kwargs: Any) -> None:
        """
        Reevaluate a record and optionally return information

        Syntax:
            reevaluate_record data_source_code record_id [-f FLAG ...]

        Examples:
            reevaluate_record customers 1001
            reevaluate_record customers 1001 -f SZ_WITH_INFO

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        reevaluate = functools.partial(
            self.sz_engine.reevaluate_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = reevaluate(kwargs["flags"]) if "flags" in kwargs else reevaluate()
        if response == "{}":
            self.last_response = self.output_response("Record reevaluated", "success")
        else:
            self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_search_by_attributes(self, **kwargs: Any) -> None:
        # search_by_attributes ATTRIBUTES [SEARCH_PROFILE] [-f FLAG ...]
        # search_by_attributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}' SEARCH -f SZ_SEARCH_BY_ATTRIBUTES_MINIMAL_ALL
        # SEARCH_PROFILE = Search profile to use (defaults to SEARCH)
        """
        Search for entities

        Syntax:
            search_by_attributes attributes [-f FLAG ...]

        Examples:
            search_by_attributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}'
            search_by_attributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}' -f SZ_SEARCH_BY_ATTRIBUTES_MINIMAL_ALL

        Arguments:
            attributes = Senzing mapped JSON containing the attributes to search on
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.search_by_attributes(
                kwargs["parsed_args"].attributes,
                kwargs["flags"],
                kwargs["parsed_args"].search_profile,
            )
        else:
            response = self.sz_engine.search_by_attributes(
                kwargs["parsed_args"].attributes,
                search_profile=kwargs["parsed_args"].search_profile,
            )

        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_why_entities(self, **kwargs: Any) -> None:
        """
        Determine how entities relate to each other

        Syntax:
            why_entities entity_id_1 entity_id_2 [-f flag ...]

        Examples:
            why_entities 96 200011
            why_entities 96 200011 -f SZ_WHY_ENTITY_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_RECORD_DEFINITION

        Arguments:
            entity_id_1 = Identifier for first entity
            entity_id_2 = Identifier for second entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        why_entities = functools.partial(
            self.sz_engine.why_entities,
            kwargs["parsed_args"].entity_id_1,
            kwargs["parsed_args"].entity_id_2,
        )

        response = why_entities(kwargs["flags"]) if "flags" in kwargs else why_entities()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_why_record_in_entity(self, **kwargs: Any) -> None:
        """
        Determine why a particular record resolved to an entity

        Syntax:
            why_record_in_entity data_source_code record_id [-f FLAG ...]

        Examples:
            why_record_in_entity reference 2121
            why_record_in_entity reference 2121 -f SZ_WHY_ENTITY_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_RECORD_DEFINITION

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        why_record = functools.partial(
            self.sz_engine.why_record_in_entity,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = why_record(kwargs["flags"]) if "flags" in kwargs else why_record()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_why_records(self, **kwargs: Any) -> None:
        """
        Determine how two records relate to each other

        Syntax:
            why_records data_source_code_1 record_id_1 data_source_code_2 record_id_2 [-f flag ...]

        Examples:
            why_records reference 2121 watchlist 2092
            why_records reference 2121 watchlist 2092 -f SZ_WHY_ENTITY_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_RECORD_DEFINITION

        Arguments:
            data_source_code_1 = Data source code for first record
            record_id_1 = Identifier for first record
            data_source_code_2 = Data source code for second record
            record_id_2 = Identifier for second record
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        why_records = functools.partial(
            self.sz_engine.why_records,
            kwargs["parsed_args"].data_source_code_1,
            kwargs["parsed_args"].record_id_1,
            kwargs["parsed_args"].data_source_code_2,
            kwargs["parsed_args"].record_id_2,
        )

        response = why_records(kwargs["flags"]) if "flags" in kwargs else why_records()
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # szproduct commands
    # -----------------------------------------------------------------------------

    @sz_cmds_decorator(cmd_has_args=False)
    def do_get_license(self) -> None:
        """
        Get license information

        Syntax:
            get_license"""

        response = self.sz_product.get_license()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_get_version(self) -> None:  # pylint: disable=invalid-name
        """
        Get version information

        Syntax:
            get_version"""

        response = self.sz_product.get_version()
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # Custom commands
    # -----------------------------------------------------------------------------

    def do_hidden(self, line: str) -> None:  # pylint: disable=unused-argument
        print()
        print("\n".join(map(str, self.__hidden_cmds)))
        print()

    def do_history(self, line: str) -> None:  # pylint: disable=unused-argument
        """
        Displays the command history

        Syntax:
            history
        """
        do_history()

    def do_json_color(self, line: str) -> None:  # pylint: disable=unused-argument
        # TODO Add to help this saves to config file and about per cmd changes
        """
        Enables/disables adding colors to JSON responses

        Syntax:
            json_color
        """
        self.color_json = not self.color_json
        print_info(f'Coloring of JSON responses {"enabled" if self.color_json else "disabled"}')

        self.write_config()

    def do_json_format(self, line: str) -> None:  # pylint: disable=unused-argument
        # TODO Add to help this saves to config file
        """
        Switch output between json (tall json) and jsonl (json lines) for JSON responses

        Syntax:
            json_format
        """
        self.format_json = not self.format_json
        print_info(f'Formatting of JSON responses {"enabled" if self.format_json else "disabled"}')

        self.write_config()

    def do_response_to_clipboard(self, line: str) -> None:  # pylint: disable=[unused-argument]
        """"""
        response_to_clipboard(self.last_response)

    @sz_cmds_decorator()
    def do_response_to_file(self, **kwargs: Any) -> None:
        """"""
        response_to_file(kwargs["parsed_args"].file_path, self.last_response)

    # TODO - Ant - if copy to clipboard after calling this don't get the reformatted response, get the original response format
    def do_response_reformat_json(self, line: str) -> None:  # pylint: disable=[unused-argument]
        """"""
        response_reformat_json(self.last_response, self.color_json, self.format_json, self.color_disabled)

    def do_scroll_output(self, line: str) -> None:  # pylint: disable=[unused-argument]
        # TODO Add to help
        """
        Switch output between using a pager or not

        Syntax:
            scroll_output
        """
        self.scroll_output = not self.scroll_output
        print_info(f'Paging of JSON responses {"enabled" if self.scroll_output else "disabled"}')

        self.write_config()

    @sz_cmds_decorator()
    def do_set_theme(self, **kwargs: Any) -> None:
        """
        Switch terminal ANSI colors

        Syntax:
            set_theme default|dark|light|{terminal}

        Note:
            - The default is terminal and recommended
        """
        Colors.set_theme(kwargs["parsed_args"].theme[0])
        self.theme = kwargs["parsed_args"].theme[0]
        self.write_config()

    def do_timer(self, line: str) -> None:  # pylint: disable=unused-argument
        """# TODO"""
        self.timer = not self.timer
        print_info(f'Timer {"enabled" if self.timer else "disabled"}')
        self.write_config()

    # -----------------------------------------------------------------------------
    # Helper methods
    # -----------------------------------------------------------------------------

    def apply_formats(
        self,
        cmd_line: str,
    ) -> str:
        """Check command for optional formatters, apply them and remove formatters from the command before running it"""
        # Convert command str to a list, lower each element to check if any formatters are present
        cmd_list_lower = [x.lower() for x in cmd_line.split()]
        formatting = [f for f in PER_CMD_FORMATTERS if f in cmd_list_lower]

        # Set formatters if any are found on the input command
        if formatting:
            # Input command as a list to remove any formatters
            cmd_list = cmd_line.split()

            for format_ in formatting:
                if format_ in ["json", "jsonl"]:
                    self.cmd_format = True
                    if format_ == "json":
                        self.format_json_cmd = True
                    if format_ == "jsonl":
                        self.format_json_cmd = False

                if format_ in [
                    "color",
                    "colour",
                    "nocolor",
                    "nocolour",
                ]:
                    self.cmd_color = True
                    if format_ in ["color", "colour"]:
                        self.color_json_cmd = True
                    if format_ in ["nocolor", "nocolour"]:
                        self.color_json_cmd = False

            # Remove any formatters from input command list and convert back to a string
            cmd_list = [c for c in cmd_list if c not in PER_CMD_FORMATTERS]
            cmd_line = " ".join(cmd_list)

        return cmd_line

    # Parses command arguments into a list of argument strings
    def parse(self, argument_string: str) -> List[str]:
        try:
            return shlex.split(argument_string)
        except ValueError as err:
            print_error(f"Unable to parse arguments: {err}")
            raise

    # Try and read configuration ini file, if one doesn't exist create one
    def read_config(self) -> None:
        config_exists = pathlib.Path(self.config_file).exists()

        if config_exists:
            try:
                config_parser = configparser.ConfigParser()
                with open(self.config_file, "r", encoding="utf-8") as _:
                    pass
                config_parser.read(self.config_file)
                self.format_json = config_parser["CONFIG"].getboolean("formatjson")
                self.color_json = config_parser["CONFIG"].getboolean("outputcolor")
                self.timer = config_parser["CONFIG"].getboolean("timer")
                self.theme = config_parser["CONFIG"]["theme"]
                self.scroll_output = config_parser["CONFIG"].getboolean("scroll_output")
            except IOError as err:
                print_warning(
                    f"Error reading configuration file {self.config_file}: {err}",
                )
            except (configparser.Error, KeyError) as err:
                print_warning(
                    f"Error reading entries from configuration file {self.config_file}: {err}",
                )
        else:
            # If a configuration file doesn't exist attempt to create one
            self.write_config()

    # Try and write configuration ini file
    def write_config(self) -> None:
        if self.docker_launched:
            return

        write_config = configparser.ConfigParser()
        write_config["CONFIG"] = {
            "formatjson": f'{"True" if self.format_json else "False"}',
            "outputcolor": f'{"True" if self.color_json else "False"}',
            "timer": f'{"True" if self.timer else "False"}',
            "theme": self.theme,
            "scroll_output": f'{"True" if self.scroll_output else "False"}',
        }

        try:
            with open(self.config_file, "w", encoding="utf-8") as config_file:
                write_config.write(config_file)
        except IOError as err:
            if not self.config_error:
                print_warning(
                    f"Error saving configuration to {self.config_file}: {err}",
                )
                self.config_error = not self.config_error
        except configparser.Error as err:
            if not self.config_error:
                print_warning(
                    f"Error writing entries to the configuration file {self.config_file}: {err}",
                )
                self.config_error = not self.config_error

    # -------------------------------------------------------------------------
    # Auto completers
    # -------------------------------------------------------------------------

    # pylint: disable=[unused-argument, invalid-name]

    # Auto complete engine flags from self.szengineflags
    def flags_completes(self, text: str, line: str) -> List[str]:
        flags = []
        if re.match(".* -f +", line):
            flags = [flag for flag in self.engine_flags_list if flag.lower().startswith(text.lower())]
        return flags

    # Auto complete engine flags and JSON key/value syntax
    def json_and_flags_completes(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        # Do not change the order of these matches!

        # comp_cmd = re.match(r"\w+ +", line)
        comp_cmd = re.match(r"\w+ +\w+ +\w+ +", line)
        if comp_cmd and len(comp_cmd.group()) == len(line):
            # print(f"{comp_cmd.group() = }")
            return ["""'{"": "", """]

        re_flags = re.search(" -f +.*$", line)
        if re_flags and re_flags.end() == endidx:
            flags = [flag for flag in self.engine_flags_list if flag.lower().startswith(text.lower())]
            return flags

        # re_j_start = re.search("'{{1}", line)
        re_j_start = re.match(r"\w+ +\w+ +\w+ +'{{1}", line)
        if re_j_start:

            # Look ahead a couple of characters...
            attr_check = line[begidx : begidx + 2]

            if re.search("'{", line[begidx:]):
                return []

            if attr_check == '":' or re.match(r"\w", attr_check):
                attrs = [attr for attr in self.attrs if attr.lower().startswith(text.lower())]
                return attrs

            if not text and line[begidx - 1 :] == '"':
                return ["}' "]

            if not text and line[begidx : begidx + 1] not in [
                '"',
                ":",
                " ",
                ",",
                "' ",
                "}",
            ]:
                if not re.search("\"}' *$", line):
                    print(f"{line = }")
                    print(f"{text = }")
                    print(f"begidx: {line[begidx:begidx] = }")
                    print(f"begidx + 1: {line[begidx:begidx+1] = }")
                    print(f"begidx + 2: {line[begidx:begidx+2] = }")
                    print(f"begidx - 1: {line[begidx-1:] = }")
                    print(f"begidx - 2: {line[begidx-2:] = }")
                    print(f"begidx - 3: {line[begidx-3:] = }")
                    print(f"begidx - 4: {line[begidx-4:] = }")
                    return ['"": "", ']

        return []

    @staticmethod
    def path_completes(
        text: str,
        line: str,
        begidx: int,
        endidx: int,
        calling_cmd: str,
    ) -> List[str]:
        """Auto complete paths for commands"""

        completes = []
        path_comp = line[len(calling_cmd) + 1 : endidx]
        fixed = line[len(calling_cmd) + 1 : begidx]
        for path in glob.glob(f"{path_comp}*"):
            path = path + os.sep if path and os.path.isdir(path) and path[-1] != os.sep else path
            completes.append(path.replace(fixed, "", 1))

        return completes

    def complete_add_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.json_and_flags_completes(text, line, begidx, endidx)

    def complete_delete_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_export_csv_entity_report(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("export_csv_entity_report +", line) and not re.match("export_csv_entity_report +.* +", line):
            return self.path_completes(text, line, begidx, endidx, "export_csv_entity_report")

        if re.match(".* -f +", line):
            return self.flags_completes(text, line)
        return []

    def complete_export_json_entity_report(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("export_json_entity_report +", line) and not re.match("export_json_entity_report +.* +", line):
            return self.path_completes(text, line, begidx, endidx, "export_json_entity_report")

        if re.match(".* -f +", line):
            return self.flags_completes(text, line)
        return []

    def complete_find_interesting_entities_by_entity_id(
        self, text: str, line: str, begidx: int, endidx: int
    ) -> List[str]:
        return self.flags_completes(text, line)

    def complete_find_interesting_entities_by_record_id(
        self, text: str, line: str, begidx: int, endidx: int
    ) -> List[str]:
        return self.flags_completes(text, line)

    def complete_find_network_by_entity_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_find_network_by_record_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_find_path_by_entity_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_find_path_by_record_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_get_entity_by_entity_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_get_entity_by_record_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_get_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_get_virtual_entity_by_record_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_how_entity_by_entity_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_preprocess_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.json_and_flags_completes(text, line, begidx, endidx)

    def complete_process_redo_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_reevaluate_entity(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_reevaluate_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_search_by_attributes(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        # return self.flags_completes(text, line)
        return self.json_and_flags_completes(text, line, begidx, endidx)

    def complete_why_record_in_entity(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_why_entities(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_why_records(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_response_to_file(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("response_to_file +", line):
            return self.path_completes(text, line, begidx, endidx, "response_to_file")
        return []

    def complete_set_theme(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("set_theme +", line):
            return [theme for theme in self.themes if theme.lower().startswith(text.lower())]
        return []

    # pylint: enable=[unused-argument, invalid-name]


# TODO - Ant - Move to helpers
def get_sz_engine_flags(flags: List[str]) -> int:
    """Detect if int or named flags are used and convert to int"""
    if flags[0] == "-1":
        return -1

    # When using an int there should only be one value, not combined like named flags
    if flags[0].isdigit():
        return int(flags[0])

    # Named engine flag(s) used, combine and return the int value
    return SzEngineFlags.combine_flags(flags)


def parse_cli_args() -> argparse.Namespace:
    """# TODO"""
    arg_parser = argparse.ArgumentParser(
        allow_abbrev=False,
        description="Utility to interact with Senzing APIs",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    arg_parser.add_argument(
        "-c",
        "--ini-file",
        help="optional path and file name of G2Module.ini to use",
    )
    # TODO Make mutually exclusive with file
    arg_parser.add_argument(
        "-C",
        "--command",
        action="append",
        nargs="+",
        help="run command(s) without starting an interactive session",
    )
    arg_parser.add_argument(
        "-f",
        "--file-to-process",
        default=None,
        help="path and file name of file with commands to process",
        nargs="?",
    )
    arg_parser.add_argument(
        "-o",
        "--capture-file",
        help="capture session output to a file",
    )
    arg_parser.add_argument(
        "-t",
        "--debug_trace",
        action="store_true",
        default=False,
        help="output debug information",
    )
    arg_parser.add_argument(
        "-cd",
        "--color_disable",
        action="store_true",
        default=False,
        help="disable coloring of output, color formatting commands will have no effect in the session",
    )
    arg_parser.add_argument(
        "-H",
        "--hist_disable",
        action="store_true",
        default=False,
        help="disable use of history file",
    )

    return arg_parser.parse_args()


def main() -> None:
    """main"""

    cli_args = parse_cli_args()

    # Check an engine configuration can be located
    engine_config = get_engine_config(cli_args.ini_file)

    cmd_obj = SzCmdShell(engine_config, cli_args)

    # Execute commands and catch ctrl-c
    try:
        # Execute command(s) non-interactively from the command line
        if cli_args.command:
            cmd_obj.commands_from_cli(cli_args.command)
            return

        # Execute a file of commands
        if cli_args.file_to_process:
            cmd_obj.commands_from_file(cli_args.file_to_process)
            return

        # Interactive session
        cmd_obj.cmdloop()
    except KeyboardInterrupt:
        return


if __name__ == "__main__":
    main()
