#! /usr/bin/env python3

""" # TODO """


import argparse
import cmd
import configparser
import functools
import glob
import json
import os
import pathlib
import re
import shlex
import sys
import textwrap
import time
from contextlib import suppress
from typing import Any, Callable, Dict, List, NoReturn, ParamSpec, TypeVar, Union

from _tool_helpers import (
    Colors,
    capture_file,
    colorize_output,
    colorize_str,
    do_help,
    do_history,
    do_shell,
    get_engine_config,
    history_setup,
    print_error,
    print_info,
    print_response,
    print_warning,
    response_reformat_json,
    response_to_clipboard,
    response_to_file,
)
from senzing import SzAbstractFactory, SzEngineFlags, SzError

T = TypeVar("T")
P = ParamSpec("P")
RT = TypeVar("RT")

# Per command JSON formatting options used in decorator
formatters = [
    "json",
    "jsonl",
    "color",
    "colour",
    "nocolor",
    "nocolour",
]


# -------------------------------------------------------------------------
# Metadata
# -------------------------------------------------------------------------

__all__ = ["SzCmdShell"]
__version__ = "0.0.1"  # See https://www.python.org/dev/peps/pep-0396/
__date__ = "2024-06-13"
__updated__ = "2024-06-13"

# Due to the way the Cmd module works, don't want doc strings on everything
# pylint: disable=missing-function-docstring


# -------------------------------------------------------------------------
# Decorators
# -------------------------------------------------------------------------


def sz_cmds_decorator(
    cmd_has_args: bool = True,
) -> Callable[[Callable[..., RT]], Callable[..., RT]]:
    """Decorator for do_* commands to parse args, display help, set response variables etc."""

    def decorator(func: Callable[..., RT]) -> Callable[..., RT]:
        @functools.wraps(func)
        def wrapper(self, *args: Any, **kwargs: Any) -> Union[None, RT]:  # type: ignore[no-untyped-def]
            cmd_args = args[0]
            # Apply and remove any command formatters
            cmd_args = self.apply_formats(cmd_args)

            if cmd_has_args:
                try:
                    # Parse arguments for a command and add to kwargs
                    # to use in calling method
                    kwargs["parsed_args"] = self.parser.parse_args([f"{func.__name__[3:]}"] + self.parse(cmd_args))

                    if "flags" in kwargs["parsed_args"] and kwargs["parsed_args"].flags:
                        kwargs["flags"] = get_engine_flags(kwargs["parsed_args"].flags)

                # Catch argument errors from parser and display the commands help
                except SystemExit:
                    self.do_help(func.__name__)
                    return None
                # Catch parsing errors such as missing single quote around JSON
                # Error is displayed in parse()
                except ValueError:
                    return None
                # Catch errors from methods such as get_engine_flags
                except (KeyError, SzError) as err:
                    print_error(err)
                    return None

            # Run the decorated method passing back kwargs for use in SDK call
            try:
                if self.timer:
                    timer_start = time.perf_counter()
                try:
                    result = func(self, **kwargs)
                except SzError as err:
                    print_error(err)
                    return
                if self.timer:
                    exec_time = time.perf_counter() - timer_start
                    print_info(
                        f"Approximate execution time (s): {exec_time:.5f}",
                    )
            except (SzError, IOError) as err:
                print_error(err)
            finally:
                self.format_json_cmd = False
                self.color_json_cmd = False
                self.cmd_color = False
                self.cmd_format = False

            return result

        return wrapper

    return decorator


# -------------------------------------------------------------------------
# Classes
# -------------------------------------------------------------------------
class SzCommandArgumentParser(argparse.ArgumentParser):
    """Subclass ArgumentParser, override error() with custom message"""

    def error(self, message: str) -> NoReturn:
        self.exit(
            2,
            colorize_output(f"\nERROR: {self.prog} - {message}\n", "error"),
        )


class SzCmdShell(cmd.Cmd):
    """Main Cmd class"""

    def __init__(
        self,
        engine_settings: str,
        # debug: bool,
        cli_args: argparse.Namespace,
        # sz_abstract_factory: SzAbstractFactory,
    ):
        super().__init__()

        self.cli_args = cli_args

        # Acquire Senzing API engines
        # self.debug_trace = debug
        self.engine_settings = engine_settings
        # self.sz_factory = sz_abstract_factory

        try:
            self.sz_factory = SzAbstractFactory(
                "sz_command", self.engine_settings, verbose_logging=self.cli_args.debug_trace
            )
            self.sz_config = self.sz_factory.create_sz_config()
            self.sz_configmgr = self.sz_factory.create_sz_configmanager()
            self.sz_diagnostic = self.sz_factory.create_sz_diagnostic()
            self.sz_engine = self.sz_factory.create_sz_engine()
            self.sz_product = self.sz_factory.create_sz_product()
        except SzError as err:
            print_error(err)
            sys.exit(1)

        # Get Senzing engine flags for use in auto completion
        self.engine_flags_list = list(SzEngineFlags.__members__.keys())

        # Collect attributes from configuration
        self.attrs = self.get_config_attrs()

        # Hide methods - could be deprecated, undocumented, not supported, experimental
        self.__hidden_cmds = (
            "do_EOF",
            "do_findInterestingEntitiesByEntityID",
            "do_findInterestingEntitiesByRecordID",
            "do_getRedoRecord",
            "do_getFeature",
            "do_help",
            "do_hidden",
            "do_shell",
        )

        # Cmd module settings
        self.intro = ""
        self.prompt = "(szcmd) "

        # Readline and history
        self.history_avail = False
        self.history_disable = self.cli_args.hist_disable
        self.history_msg = ""

        # Capture output
        self.capture_file = None

        # For pretty printing JSON responses
        self.cmd_color = False
        self.cmd_format = False
        self.color_json = True
        self.color_json_cmd = False
        self.format_json = False
        self.format_json_cmd = False

        # Themes
        self.theme = "TERMINAL"
        self.themes = ["default", "dark", "light", "terminal"]

        # General
        self.last_response = ""
        self.scroll_output = False
        self.timer = False

        # Configuration ini file
        path = pathlib.Path(sys.argv[0])
        file_str = f"~/.{path.stem.lower()}{'.ini'}"
        self.config_file = pathlib.Path(file_str).expanduser()

        # Display can't read/write config message once, not at all in container
        self.config_error = False
        env_launched = os.getenv("SENZING_DOCKER_LAUNCHED", None)
        self.docker_launched = True if env_launched in ("y", "yes", "t", "true", "on", "1") else False

        # -------------------------------------------------------------------------
        # do_* command parsers
        # -------------------------------------------------------------------------

        self.parser = SzCommandArgumentParser(
            add_help=False,
            prog="sz_command",
            usage=argparse.SUPPRESS,
        )
        self.subparsers = self.parser.add_subparsers()

        # szconfig parsers

        getConfig_parser = self.subparsers.add_parser("getConfig", usage=argparse.SUPPRESS)
        getConfig_parser.add_argument("config_id", type=int)

        # szconfigmanager parsers

        replaceDefaultConfigID_parser = self.subparsers.add_parser("replaceDefaultConfigID", usage=argparse.SUPPRESS)
        replaceDefaultConfigID_parser.add_argument("current_default_config_id", type=int)
        replaceDefaultConfigID_parser.add_argument("new_default_config_id", type=int)

        setDefaultConfigID_parser = self.subparsers.add_parser("setDefaultConfigID", usage=argparse.SUPPRESS)
        setDefaultConfigID_parser.add_argument("config_id", type=int)

        # szdiagnostic parsers

        checkDatastorePerformance_parser = self.subparsers.add_parser(
            "checkDatastorePerformance", usage=argparse.SUPPRESS
        )
        checkDatastorePerformance_parser.add_argument("secondsToRun", default=3, nargs="?", type=int)

        getFeature_parser = self.subparsers.add_parser("getFeature", usage=argparse.SUPPRESS)
        getFeature_parser.add_argument("featureID", type=int)

        purgeRepository_parser = self.subparsers.add_parser("purgeRepository", usage=argparse.SUPPRESS)
        purgeRepository_parser.add_argument(
            "-FORCEPURGE",
            "--FORCEPURGE",
            action="store_true",
            default=False,
            dest="force_purge",
            required=False,
        )

        # szengine parsers

        addRecord_parser = self.subparsers.add_parser("addRecord", usage=argparse.SUPPRESS)
        addRecord_parser.add_argument("data_source_code")
        addRecord_parser.add_argument("record_id")
        addRecord_parser.add_argument("record_definition")
        addRecord_parser.add_argument("-f", "--flags", nargs="+", required=False)

        deleteRecord_parser = self.subparsers.add_parser("deleteRecord", usage=argparse.SUPPRESS)
        deleteRecord_parser.add_argument("data_source_code")
        deleteRecord_parser.add_argument("record_id")
        deleteRecord_parser.add_argument("-f", "--flags", nargs="+", required=False)

        exportCSVEntityReport_parser = self.subparsers.add_parser("exportCSVEntityReport", usage=argparse.SUPPRESS)
        exportCSVEntityReport_parser.add_argument("output_file")
        exportCSVEntityReport_parser.add_argument("-f", "--flags", nargs="+", required=False)
        exportCSVEntityReport_parser.add_argument("-t", "--csv_column_list", required=False, type=str)

        exportJSONEntityReport_parser = self.subparsers.add_parser("exportJSONEntityReport", usage=argparse.SUPPRESS)
        exportJSONEntityReport_parser.add_argument("output_file")
        exportJSONEntityReport_parser.add_argument("-f", "--flags", nargs="+", required=False)

        findInterestingEntitiesByEntityID_parser = self.subparsers.add_parser(
            "findInterestingEntitiesByEntityID", usage=argparse.SUPPRESS
        )
        findInterestingEntitiesByEntityID_parser.add_argument("entity_id", type=int)
        findInterestingEntitiesByEntityID_parser.add_argument("-f", "--flags", nargs="+", required=False)

        findInterestingEntitiesByRecordID_parser = self.subparsers.add_parser(
            "findInterestingEntitiesByRecordID", usage=argparse.SUPPRESS
        )
        findInterestingEntitiesByRecordID_parser.add_argument("data_source_code")
        findInterestingEntitiesByRecordID_parser.add_argument("record_id")
        findInterestingEntitiesByRecordID_parser.add_argument("-f", "--flags", nargs="+", required=False)

        def list_of_ints(ints: str) -> List[int]:
            # print(list(map(int, ints.split(","))))
            return list(map(int, ints.split(",")))

        findNetworkByEntityID_parser = self.subparsers.add_parser("findNetworkByEntityID", usage=argparse.SUPPRESS)
        # findNetworkByEntityID_parser.add_argument("entity_list")
        findNetworkByEntityID_parser.add_argument("entity_list", type=list_of_ints)
        findNetworkByEntityID_parser.add_argument("max_degrees", type=int)
        findNetworkByEntityID_parser.add_argument("build_out_degree", type=int)
        findNetworkByEntityID_parser.add_argument("max_entities", type=int)
        findNetworkByEntityID_parser.add_argument("-f", "--flags", nargs="+", required=False)

        def list_of_tuples(rec_keys: str) -> list[tuple[str, str]]:

            error_msg = "error parsing, expecting: 'DATA_SOURCE:RECORD_ID, DATA_SOURCE:RECORD_ID, ...'"

            if "," not in rec_keys or ":" not in rec_keys:
                raise argparse.ArgumentTypeError(error_msg)

            try:
                rec_keys_list = [
                    (values[0].strip(), values[1].strip())
                    for values in (aset.split(":") for aset in rec_keys.split(","))
                ]
                print(rec_keys_list)
            except IndexError as err:
                raise argparse.ArgumentTypeError(error_msg) from err

            return rec_keys_list

        findNetworkByRecordID_parser = self.subparsers.add_parser("findNetworkByRecordID", usage=argparse.SUPPRESS)
        # findNetworkByRecordID_parser.add_argument("record_list")
        findNetworkByRecordID_parser.add_argument("record_list", type=list_of_tuples)
        findNetworkByRecordID_parser.add_argument("max_degrees", type=int)
        findNetworkByRecordID_parser.add_argument("build_out_degree", type=int)
        findNetworkByRecordID_parser.add_argument("max_entities", type=int)
        findNetworkByRecordID_parser.add_argument("-f", "--flags", nargs="+", required=False)

        findPathByEntityID_parser = self.subparsers.add_parser("findPathByEntityID", usage=argparse.SUPPRESS)
        findPathByEntityID_parser.add_argument("start_entity_id", type=int)
        findPathByEntityID_parser.add_argument("end_entity_id", type=int)
        findPathByEntityID_parser.add_argument("max_degrees", type=int)
        findPathByEntityID_parser.add_argument("-e", "--exclusions", default="", nargs="?", required=False)
        findPathByEntityID_parser.add_argument("-r", "--required_data_sources", default="", nargs="?", required=False)
        findPathByEntityID_parser.add_argument("-f", "--flags", nargs="+", required=False)

        findPathByRecordID_parser = self.subparsers.add_parser("findPathByRecordID", usage=argparse.SUPPRESS)
        findPathByRecordID_parser.add_argument("start_data_source_code")
        findPathByRecordID_parser.add_argument("start_record_id")
        findPathByRecordID_parser.add_argument("end_data_source_code")
        findPathByRecordID_parser.add_argument("end_record_id")
        findPathByRecordID_parser.add_argument("max_degrees", type=int)
        findPathByRecordID_parser.add_argument("-e", "--exclusions", default="", nargs="?", required=False)
        findPathByRecordID_parser.add_argument("-r", "--required_data_sources", default="", nargs="?", required=False)
        findPathByRecordID_parser.add_argument("-f", "--flags", nargs="+", required=False)

        getEntityByEntityID_parser = self.subparsers.add_parser("getEntityByEntityID", usage=argparse.SUPPRESS)
        getEntityByEntityID_parser.add_argument("entity_id", type=int)
        getEntityByEntityID_parser.add_argument("-f", "--flags", nargs="+", required=False)

        getEntityByRecordID_parser = self.subparsers.add_parser("getEntityByRecordID", usage=argparse.SUPPRESS)
        getEntityByRecordID_parser.add_argument("data_source_code")
        getEntityByRecordID_parser.add_argument("record_id")
        getEntityByRecordID_parser.add_argument("-f", "--flags", nargs="+", required=False)

        getRecord_parser = self.subparsers.add_parser("getRecord", usage=argparse.SUPPRESS)
        getRecord_parser.add_argument("data_source_code")
        getRecord_parser.add_argument("record_id")
        getRecord_parser.add_argument("-f", "--flags", nargs="+", required=False)

        getVirtualEntityByRecordID_parser = self.subparsers.add_parser(
            "getVirtualEntityByRecordID", usage=argparse.SUPPRESS
        )
        # getVirtualEntityByRecordID_parser.add_argument("record_list")
        getVirtualEntityByRecordID_parser.add_argument("record_list", type=list_of_tuples)
        getVirtualEntityByRecordID_parser.add_argument("-f", "--flags", nargs="+", required=False)

        howEntityByEntityID_parser = self.subparsers.add_parser("howEntityByEntityID", usage=argparse.SUPPRESS)
        howEntityByEntityID_parser.add_argument("entity_id", type=int)
        howEntityByEntityID_parser.add_argument("-f", "--flags", nargs="+", required=False)

        preprocessRecord_parser = self.subparsers.add_parser("preprocessRecord", usage=argparse.SUPPRESS)
        preprocessRecord_parser.add_argument("record_definition")
        preprocessRecord_parser.add_argument("-f", "--flags", nargs="+", required=False)

        processRedoRecord_parser = self.subparsers.add_parser("processRedoRecord", usage=argparse.SUPPRESS)
        processRedoRecord_parser.add_argument("redo_record")
        processRedoRecord_parser.add_argument("-f", "--flags", nargs="+", required=False)

        reevaluateEntity_parser = self.subparsers.add_parser("reevaluateEntity", usage=argparse.SUPPRESS)
        reevaluateEntity_parser.add_argument("entity_id", type=int)
        reevaluateEntity_parser.add_argument("-f", "--flags", nargs="+", required=False)

        reevaluateRecord_parser = self.subparsers.add_parser("reevaluateRecord", usage=argparse.SUPPRESS)
        reevaluateRecord_parser.add_argument("data_source_code")
        reevaluateRecord_parser.add_argument("record_id")
        reevaluateRecord_parser.add_argument("-f", "--flags", nargs="+", required=False)

        searchByAttributes_parser = self.subparsers.add_parser("searchByAttributes", usage=argparse.SUPPRESS)
        searchByAttributes_parser.add_argument("attributes")
        searchByAttributes_parser.add_argument("search_profile", default="SEARCH", nargs="?")
        searchByAttributes_parser.add_argument("-f", "--flags", nargs="+", required=False)

        whyEntities_parser = self.subparsers.add_parser("whyEntities", usage=argparse.SUPPRESS)
        whyEntities_parser.add_argument("entity_id1", type=int)
        whyEntities_parser.add_argument("entity_id2", type=int)
        whyEntities_parser.add_argument("-f", "--flags", nargs="+", required=False)

        whyRecordInEntity_parser = self.subparsers.add_parser("whyRecordInEntity", usage=argparse.SUPPRESS)
        whyRecordInEntity_parser.add_argument("data_source_code")
        whyRecordInEntity_parser.add_argument("record_id")
        whyRecordInEntity_parser.add_argument("-f", "--flags", nargs="+", required=False)

        whyRecords_parser = self.subparsers.add_parser("whyRecords", usage=argparse.SUPPRESS)
        whyRecords_parser.add_argument("data_source_code1")
        whyRecords_parser.add_argument("record_id1")
        whyRecords_parser.add_argument("data_source_code2")
        whyRecords_parser.add_argument("record_id2")
        whyRecords_parser.add_argument("-f", "--flags", nargs="+", required=False)

        # Utility parsers

        responseToFile_parser = self.subparsers.add_parser("responseToFile", usage=argparse.SUPPRESS)
        responseToFile_parser.add_argument("file_path")

        setTheme_parser = self.subparsers.add_parser("setTheme", usage=argparse.SUPPRESS)
        setTheme_parser.add_argument(
            "theme",
            choices=self.themes,
            nargs=1,
        )

    def get_config_attrs(self) -> List[str]:
        # TODO - Work in progress for JSON autocomplete
        config_id = self.sz_engine.get_active_config_id()
        config = self.sz_configmgr.get_config(config_id)
        config_json = json.loads(config)
        cfg_attr = config_json["G2_CONFIG"]["CFG_ATTR"]
        attr_list = []
        for attr in cfg_attr:
            # print(attr["ATTR_CODE"] + "-" + attr["INTERNAL"])
            if attr["INTERNAL"].lower() == "no":
                attr_list.append(attr["ATTR_CODE"])

        return attr_list

    # Call helper function to format and print command responses with
    # constant values
    def output_response(self, response: Union[int, str], color: str = "") -> str:
        formatted_response: str = print_response(
            response,
            self.color_json,
            self.color_json_cmd,
            self.format_json,
            self.format_json_cmd,
            self.cmd_color,
            self.cmd_format,
            self.scroll_output,
            color,
        )

        return formatted_response

    # -------------------------------------------------------------------------
    # Cmd module methods
    # -------------------------------------------------------------------------

    def cmdloop(self, intro: None = None) -> None:
        while True:
            try:
                super(SzCmdShell, self).cmdloop(intro=self.intro)
                # super().cmdloop(intro=None)
                break
            except KeyboardInterrupt:
                if input(
                    colorize_output(
                        "\n\nAre you sure you want to exit? (y/n) ",
                        "caution",
                    )
                ) in ["y", "Y", "yes", "YES"]:
                    break
                else:
                    print()
            except TypeError as err:
                print_error(err)

    # Override function from cmd module to make command completion case-insensitive
    def completenames(self, text: str, *ignored: Any) -> List[str]:
        do_text = "do_" + text
        return [a[3:] for a in self.get_names() if a.lower().startswith(do_text.lower())]

    @staticmethod
    def do_EOF(_):  # type: ignore[no-untyped-def] # pylint: disable=invalid-name
        return True

    def do_exit(self, _) -> bool:  # type: ignore[no-untyped-def]
        self.do_quit(_)
        return True

    @staticmethod
    def do_quit(_) -> bool:  # type: ignore[no-untyped-def]
        return True

    def do_shell(self, line: str) -> None:
        do_shell(self, line)

    # Handle unknown commands
    def default(self, line: str) -> None:
        print_warning("Unknown command, type help or ?")

    # Do nothing if line is empty
    def emptyline(self) -> bool:
        return False

    # Override in cmd module to return methods for autocomplete and help
    # ignoring any hidden commands
    def get_names(self, include_hidden: bool = False) -> List[str]:
        if not include_hidden:
            return [n for n in dir(self.__class__) if n not in self.__hidden_cmds]

        return list(dir(self.__class__))

    def postcmd(self, stop: bool, line: str) -> bool:
        if self.capture_file and self.last_response:
            self.capture_file.write(f"{self.prompt}{line}\n\n")
            self.capture_file.write(f"{self.last_response}\n\n")
            self.capture_file.flush()

        return cmd.Cmd.postcmd(self, stop, line)

    def postloop(self) -> None:
        if self.capture_file:
            self.capture_file.close()

    def precmd(self, line: str) -> str:
        return line
        # return cmd.Cmd.precmd(self, line)

    def preloop(self) -> None:
        if self.cli_args.capture_file:
            with suppress(IOError):
                self.capture_file = capture_file(self.cli_args.capture_file)

        if not self.history_disable:
            history_check = history_setup()
            # Non-empty string means error and msg was returned
            if history_check:
                print_warning(history_check)

        # Check if there is a config file and use config
        if not self.docker_launched:
            self.read_config()
            self.write_config()

        # Initially set theme to use the default colors set by the terminal
        Colors.set_theme(self.theme)

        print_info("Welcome to sz_command. Type help or ? for help")

    # -------------------------------------------------------------------------
    # Non-interactive input methods
    # -------------------------------------------------------------------------

    # Read commands from a file and call
    # TODO - Ant - What happens with the split if there is JSON with a space in it! Same for commands_from_cli. Have to use a list somehow to not break on space or remove the split?
    def commands_from_file(self, file_name: str) -> None:
        """Read commands from a file and call the matching commands"""
        try:
            with open(file_name, encoding="utf-8") as cmds_file:
                for read_line in cmds_file:
                    read_line = read_line.strip()
                    # Apply and remove any command formatters
                    cmd_line = self.apply_formats(read_line)

                    # Check for comment prefixes
                    if not read_line or read_line[0:1] in ("#", "-", "/"):
                        continue

                    (cmd_, *args) = cmd_line.split()
                    do_cmd = f"do_{cmd_}"
                    print(f"\n----- {read_line} -----")

                    if do_cmd not in dir(self):
                        print_error(f"Command {cmd_} not found")
                        continue

                    try:
                        func = getattr(self, do_cmd)
                        func(" ".join(args))
                    except (ValueError, TypeError) as err:
                        print_error(f"Problem with command: {err}")
        except OSError as err:
            print_error(err)

    # Run a single command from the CLI
    def commands_from_cli(self, commands: List[List[str]]) -> None:
        """# TODO"""

        # There could be multiple commands and associated arguments in commands[]
        for each_cmd in commands:
            # TODO - Ant -  Can the list be empty from -C or does argparse ensure there is a value?
            # single_cmd_str = " ".join(single_cmd)
            print(f"\n{each_cmd = }", flush=True)
            print(f"\n{type(each_cmd) = }", flush=True)
            requested_cmd = each_cmd[0]
            requested_args = [i for i in each_cmd if i != requested_cmd]
            print(f"\n{requested_cmd = }", flush=True)
            print(f"\n{requested_args = }", flush=True)
            cmd_args = " ".join(requested_args)
            print(f"\n{cmd_args = }", flush=True)
            # Apply and remove any command formatters
            # cmd_no_formatting = self.apply_formats(single_cmd_str)
            # args_no_formatting = self.apply_formats(cmd_args)
            # print(f"\n{args_no_formatting = }", flush=True)
            # if not cmd_no_formatting:
            # continue

            # Get the command name to append to do_ and separate the args for the call
            # requested_cmd = cmd_no_formatting[0]
            # requested_args = requested_cmd.replace(requested_cmd, "")
            do_cmd = f"do_{requested_cmd}"
            print(f"\n{do_cmd = }", flush=True)

            if do_cmd not in dir(self):
                print_error(f"Command {do_cmd} not found")
                return

            try:
                do_method = getattr(self, do_cmd)
                do_method(cmd_args)
            except (ValueError, TypeError) as err:
                print_error(f"Problem with command: {err}")

        # cmd_ = commands[0]
        # commands.remove(cmd_)
        # do_cmd = f"do_{cmd_}"
        # if do_cmd not in dir(self):
        #     print_error(f"Command {cmd_} not found")
        #     return

        # try:
        #     do_method = getattr(self, do_cmd)
        #     do_method(" ".join(commands))
        # except (ValueError, TypeError) as err:
        #     print_error(f"Problem with command: {err}")

    # -------------------------------------------------------------------------
    # Custom help
    # -------------------------------------------------------------------------

    def do_help(self, arg: str = "") -> None:
        do_help(self, arg)

    def help_all(self) -> None:
        self.do_help()

    @staticmethod
    def help_overview() -> None:
        print(
            textwrap.dedent(
                f"""
        {colorize_str('This utility allows you to interact with the Senzing APIs.', 'dim')}

        {colorize_str('Help', 'highlight2')}
            {colorize_str('- View help for a command:', 'dim')} help COMMAND
            {colorize_str('- View all commands:', 'dim')} help all

        {colorize_str('Tab Completion', 'highlight2')}
            {colorize_str('- Tab completion is available for commands, files and engine flags', 'dim')}
            {colorize_str('- Hit tab on a blank line to see all commands', 'dim')}

        {colorize_str('JSON Formatting', 'highlight2')}
            {colorize_str('- Change JSON formatting by adding "json" or "jsonl" to the end of a command', 'dim')}
                - getEntityByEntityID 1001 jsonl

            {colorize_str('- Can be combined with color formatting options', 'dim')}
                - getEntityByEntityID 1001 jsonl nocolor

            {colorize_str('- Set the JSON format for the session, saves the preference to a configuration file for use across sessions', 'dim')}
            {colorize_str('- Specifying the JSON and color formatting options at the end of a command override this setting for that command', 'dim')}
                - setOutputFormat json|jsonl

            {colorize_str('- Convert last response output between json and jsonl', 'dim')}
                - responseReformatJson

        {colorize_str('Color Formatting', 'highlight2')}
            {colorize_str('- Add or remove colors from JSON formatting by adding "color", "colour", "nocolor" or "nocolour" to the end of a command', 'dim')}
                - getEntityByEntityID 1001 color

            {colorize_str('- Can be combined with JSON formatting options', 'dim')}
                - getEntityByEntityID 1001 color jsonl

            {colorize_str('- Set the color formatting for the session, saves the preference to a configuration file for use across sessions', 'dim')}
            {colorize_str('- Specifying the JSON and color formatting options at the end of a command override this setting for that command', 'dim')}
                - setOutputColor color|colour|nocolor|nocolour

        {colorize_str('Capturing Output', 'highlight2')}
            {colorize_str('- Capture the last response output to a file or the clipboard', 'dim')}
                - responseToClipboard
                - responseToFile /tmp/myoutput.json
            {colorize_str('- responseToClipboard does not work in containers or SSH sessions', 'dim')}

        {colorize_str('History', 'highlight2')}
            {colorize_str('- Arrow keys to cycle through history of commands', 'dim')}
            {colorize_str('- Ctrl-r can be used to search history', 'dim')}
            {colorize_str('- Display history:', 'dim')} history

        {colorize_str('Timer', 'highlight2')}
            {colorize_str('- Toggle on/off approximate time a command takes to complete', 'dim')}
            {colorize_str('- Turn off JSON formatting and color output for higher accuracy', 'dim')}
                - timer

        {colorize_str('Shell', 'highlight2')}
            {colorize_str('- Run basic OS shell commands', 'dim')}
                - ! ls

        {colorize_str('Support', 'highlight2')}
            {colorize_str('- Senzing Support:', 'dim')} {colorize_str('https://senzing.zendesk.com/hc/en-us/requests/new', 'highlight1,underline')}
            {colorize_str('- Senzing Knowledge Center:', 'dim')} {colorize_str('https://senzing.zendesk.com/hc/en-us', 'highlight1,underline')}
            {colorize_str('- API Docs:', 'dim')} {colorize_str('https://docs.senzing.com', 'highlight1,underline')}

        """
            )
        )

    # -----------------------------------------------------------------------------
    # SDK commands
    # -----------------------------------------------------------------------------

    # -----------------------------------------------------------------------------
    # szconfig commands
    # -----------------------------------------------------------------------------

    @sz_cmds_decorator(cmd_has_args=False)
    def do_getTemplateConfig(self) -> None:
        """
        Get a template configuration

        Syntax:
            getTemplateConfig

        Notes:
            - Use responseToClipboard to send output to clipboard

            - Use responseToFile to send output to a file
        """

        config_handle = self.sz_config.create_config()
        response = self.sz_config.export_config(config_handle)
        self.sz_config.close_config(config_handle)
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # szconfigmanager commands
    # -----------------------------------------------------------------------------

    @sz_cmds_decorator()
    def do_getConfig(self, **kwargs: Dict[str, Any]) -> None:  # pylint: disable=invalid-name
        """
        Get a configuration

        Syntax:
            getConfig CONFIG_ID

        Example:
            getConfig 4180061352

        Arguments:
            CONFIG_ID = Configuration identifier

        Notes:
            - Retrieve the active configuration identifier with getActiveConfigID

            - Retrieve a list of configurations and identifiers with getConfigList"""

        response = self.sz_configmgr.get_config(kwargs["parsed_args"].config_id)  # type: ignore
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_getConfigs(self) -> None:
        """
        Get a list of current configurations

        Syntax:
            getConfigList"""

        response = self.sz_configmgr.get_configs()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_getDefaultConfigID(self) -> None:
        """
        Get the default configuration ID

        Syntax:
            getDefaultConfigID"""

        response = self.sz_configmgr.get_default_config_id()
        self.last_response = self.output_response(response, "success")

    @sz_cmds_decorator()
    def do_replaceDefaultConfigID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Replace the default configuration ID

        Syntax:
            replaceDefaultConfigID CURRENT_DEFAULT_CONFIG_ID NEW_DEFAULT_CONFIG_ID

        Example:
            replaceDefaultConfigID 4180061352 2787925967

        Arguments:
            CURRENT_DEFAULT_CONFIG_ID = Configuration identifier
            NEW_DEFAULT_CONFIG_ID = Configuration identifier

        Notes:
            - Retrieve a list of configurations and identifiers with getConfigList"""

        self.sz_configmgr.replace_default_config_id(
            kwargs["parsed_args"].current_default_config_id,
            kwargs["parsed_args"].new_default_config_id,
        )
        self.output_response("New default config set, reinitializing...", "success")
        self.sz_factory.reinitialize(kwargs["parsed_args"].new_default_config_id)

        # Configuration has changed, update attributes from configuration
        self.attrs = self.get_config_attrs()
        # TODO Test this, resetting last_response in pre/-cmd
        # self.last_response = ""

    @sz_cmds_decorator()
    def do_setDefaultConfigID(self, **kwargs):  # type: ignore[no-untyped-def]
        """
        Set the default configuration ID

        Syntax:
            setDefaultConfigID CONFIG_ID

        Example:
            setDefaultConfigID 4180061352

        Arguments:
            CONFIG_ID = Configuration identifier

        Notes:
            - Retrieve a list of configurations and identifiers with getConfigList"""

        self.sz_configmgr.set_default_config_id(kwargs["parsed_args"].config_id)
        self.output_response("Default config set, reinitializing...", "success")
        # Configuration has changed, update attributes from configuration
        self.attrs = self.get_config_attrs()
        # self.last_response = ""

    # -----------------------------------------------------------------------------
    # szdiagnostic commands
    # -----------------------------------------------------------------------------

    @sz_cmds_decorator()
    def do_checkDatastorePerformance(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Run a performance check on the database

        Syntax:
            checkDatastorePerformance [SECONDS]
            checkDatastorePerformance

        Arguments:
            SECONDS = Time in seconds to run check, default is 3"""

        response = self.sz_diagnostic.check_datastore_performance(kwargs["parsed_args"].secondsToRun)
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_getDatastoreInfo(self) -> None:
        """
        Get data store information

        Syntax:
            getDatastoreInfo"""

        response = self.sz_diagnostic.get_datastore_info()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_getFeature(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Get feature information

        Syntax:
            getFeature FEATURE_ID

        Examples:
            getFeature 1

        Arguments:
            FEATURE_ID = Identifier of feature"""

        response = self.sz_diagnostic.get_feature(kwargs["parsed_args"].featureID)
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_purgeRepository(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Purge Senzing database of all data

        Syntax:
            purgeRepository [--FORCEPURGE]

        Example:
            purgeRepository

        Arguments:
            --FORCEPURGE = Don't prompt before purging. USE WITH CAUTION!

        Caution:
            - This deletes all data in the Senzing database!"""

        purge_msg = colorize_output(
            textwrap.dedent(
                """

                ********** WARNING **********

                This will purge all currently loaded data from the senzing database!
                Before proceeding, all instances of senzing (custom code, rest api, redoer, etc.) must be shut down.

                ********** WARNING **********

                Are you sure you want to purge the Senzing database? Type YESPURGESENZING to purge: """
            ),
            "warning",
        )

        if not kwargs["parsed_args"].force_purge:
            if input(purge_msg) != "YESPURGESENZING":
                print("\nSenzing repository not purged\n")
                return

        self.sz_diagnostic.purge_repository()
        # TODO Test this, resetting last_response in pre/-cmd
        # self.last_response = ""
        print("\nSenzing repository purged\n")

    # -----------------------------------------------------------------------------
    # szengine commands
    # -----------------------------------------------------------------------------

    @sz_cmds_decorator()
    def do_addRecord(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Add a record and optionally return information

        Syntax:
            addRecord DSRC_CODE RECORD_ID RECORD_DEFINITION [-f FLAG ...]

        Examples:
            addRecord test 1 '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}'
            addRecord test 1 '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}' -f SZ_WITH_INFO

        Arguments:
            DSRC_CODE = Data source code
            RECORD_ID = Record identifier
            RECORD_DEFINITION = Senzing mapped JSON representation of a record
            FLAG = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """
        add_record = functools.partial(
            self.sz_engine.add_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
            kwargs["parsed_args"].record_definition,
        )

        response = add_record(kwargs["flags"]) if "flags" in kwargs else add_record()

        if response == "{}":
            self.last_response = self.output_response("Record added", "success")
        else:
            self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_countRedoRecords(self) -> None:
        """
        Counts the number of records in the redo queue

        Syntax:
            countRedoRecords"""

        response = self.sz_engine.count_redo_records()
        if not response:
            self.last_response = self.output_response("No redo records", "info")
        else:
            self.last_response = self.output_response(response, "success")

    @sz_cmds_decorator()
    def do_deleteRecord(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Delete a record and optionally return information

        Syntax:
            deleteRecord DSRC_CODE RECORD_ID [-f FLAG ...]

        Examples:
            deleteRecord test 1
            deleteRecord test 1 -f SZ_WITH_INFO

        Arguments:
            DSRC_CODE = Data source code
            RECORD_ID = Record identifier
            FLAG = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        delete_record = functools.partial(
            self.sz_engine.delete_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = delete_record(kwargs["flags"]) if "flags" in kwargs else delete_record()

        if response == "{}":
            self.last_response = self.output_response("Record deleted.", "success")
        else:
            self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_exportCSVEntityReport(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Export repository contents as CSV

        Syntax:
            exportCSVEntityReport OUTPUT_FILE [-t CSV_COLUMN_LIST,...] [-f FLAG ...]

        Examples:
            exportCSVEntityReport export.csv
            exportCSVEntityReport export.csv -t RESOLVED_ENTITY_ID,RELATED_ENTITY_ID,MATCH_LEVEL,MATCH_KEY,DATA_SOURCE,RECORD_ID
            exportCSVEntityReport export.json -F json -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_EXPORT_INCLUDE_ALL_ENTITIES

        Arguments:
            OUTPUT_FILE = File to save export to
            CSV_COLUMN_LIST = Comma separated list of output columns (don't specify for defaults)
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Available CSV_COLUMNs
                - RESOLVED_ENTITY_ID,RELATED_ENTITY_ID,MATCH_LEVEL,MATCH_KEY,DATA_SOURCE,RECORD_ID,RESOLVED_ENTITY_NAME,RECORD_DEFINITION,ERRULE_CODE

            - Engine flag details https://docs.senzing.com/flags/index.html

        Caution:
            - Export isn't intended for exporting large numbers of entities and associated data source record information.
              Beyond 100M+ data source records isn't suggested. For exporting overview entity and relationship data for
              analytical purposes outside of Senzing please review the following article.

              https://senzing.zendesk.com/hc/en-us/articles/360010716274--Advanced-Replicating-the-Senzing-results-to-a-Data-Warehouse
        """
        rec_cnt = 0

        export_csv = functools.partial(
            self.sz_engine.export_csv_entity_report,
            kwargs["parsed_args"].csv_column_list,
        )

        try:
            export_handle = export_csv(kwargs["flags"]) if "flags" in kwargs else export_csv()

            with open(kwargs["parsed_args"].output_file, "w", encoding="utf-8") as csv_out:

                while True:
                    export_record = self.sz_engine.fetch_next(export_handle)
                    if not export_record:
                        break
                    csv_out.write(export_record)
                    rec_cnt += 1
                    if rec_cnt % 1000 == 0:
                        print(f"Exported {rec_cnt} records...", flush=True)

                self.sz_engine.close_export(export_handle)
        except (SzError, IOError) as err:
            print_error(err)
        else:
            self.output_response(f"Total exported records: {rec_cnt}", "success")
            # self.last_response = ""

    @sz_cmds_decorator()
    def do_exportJSONEntityReport(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Export repository contents as JSON

        Syntax:
            exportJSONEntityReport OUTPUT_FILE [-f FLAG ...]

        Examples:
            exportJSONEntityReport export.json
            exportJSONEntityReport export.json -f SZ_EXPORT_INCLUDE_RESOLVED SZ_EXPORT_INCLUDE_POSSIBLY_SAME

        Arguments:
            OUTPUT_FILE = File to save export to
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html

        Caution:
            - Export isn't intended for exporting large numbers of entities and associated data source record information.
              Beyond 100M+ data source records isn't suggested. For exporting overview entity and relationship data for
              analytical purposes outside of Senzing please review the following article.

              https://senzing.zendesk.com/hc/en-us/articles/360010716274--Advanced-Replicating-the-Senzing-results-to-a-Data-Warehouse
        """

        rec_cnt = 0

        export_json = functools.partial(
            self.sz_engine.export_json_entity_report,
        )

        try:
            export_handle = export_json(kwargs["flags"]) if "flags" in kwargs else export_json()

            with open(kwargs["parsed_args"].output_file, "w", encoding="utf-8") as data_out:
                while True:
                    export_record = self.sz_engine.fetch_next(export_handle)
                    if not export_record:
                        break
                    data_out.write(export_record)
                    rec_cnt += 1
                    if rec_cnt % 1000 == 0:
                        print(f"Exported {rec_cnt} records...", flush=True)

                self.sz_engine.close_export(export_handle)
        except (SzError, IOError) as err:
            print_error(err)
        else:
            self.output_response(f"Total exported records: {rec_cnt}", "success")
            # self.last_response = ""

    @sz_cmds_decorator()
    def do_findInterestingEntitiesByEntityID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Find interesting entities close to an entity by resolved entity identifier

        Syntax:
            findInterestingEntitiesByEntityID ENTITY_ID [-f FLAG ...]

        Example:
            findInterestingEntitiesByEntityID 1

        Arguments:
            ENTITY_ID = Identifier for an entity
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html

            - Experimental feature requires additional configuration, contact support@senzing.com
        """

        if "flags" in kwargs:
            response = self.sz_engine.find_interesting_entities_by_entity_id(
                kwargs["parsed_args"].entity_id, kwargs["flags"]
            )
        else:
            response = self.sz_engine.find_interesting_entities_by_entity_id(kwargs["parsed_args"].entity_id)

        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_findInterestingEntitiesByRecordID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Find interesting entities close to an entity by record identifier

        Syntax:
            findInterestingEntitiesByRecordID DSRC_CODE RECORD_ID [-f FLAG ...]

        Example:
            findInterestingEntitiesByRecordID customers 1001

        Arguments:
            DSRC_CODE = Data source code
            RECORD_ID = Record identifier
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html

            - Experimental feature requires additional configuration, contact support@senzing.com
        """

        if "flags" in kwargs:
            response = self.sz_engine.find_interesting_entities_by_record_id(
                kwargs["parsed_args"].data_source_code,
                kwargs["parsed_args"].record_id,
                kwargs["flags"],
            )
        else:
            response = self.sz_engine.find_interesting_entities_by_record_id(
                kwargs["parsed_args"].data_source_code,
                kwargs["parsed_args"].record_id,
            )

        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_findNetworkByEntityID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Find network between entities

        Syntax:
            findNetworkByEntityID ENTITY_LIST MAX_DEGREES BUILD_OUT_DEGREE MAX_ENTITIES [-f FLAG ...]

        Example:
            findNetworkByEntityID '{"ENTITIES":[{"ENTITY_ID":"6"},{"ENTITY_ID":"11"},{"ENTITY_ID":"9"}]}' 4 3 20

        Arguments:
            ENTITY_LIST = JSON document listing entities to find paths between and networks around
            MAX_DEGREES = Maximum number of relationships to search for a path
            BUILD_OUT_DEGREE = Maximum degree of relationships to include around each entity
            MAX_ENTITIES = Maximum number of entities to return
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.find_network_by_entity_id(
                kwargs["parsed_args"].entity_list,
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].build_out_degree,
                kwargs["parsed_args"].max_entities,
                kwargs["flags"],
            )
        else:
            response = self.sz_engine.find_network_by_entity_id(
                kwargs["parsed_args"].entity_list,
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].build_out_degree,
                kwargs["parsed_args"].max_entities,
            )

        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_findNetworkByRecordID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Find network between records

        Syntax:
            findNetworkByRecordID RECORD_LIST MAX_DEGREES BUILD_OUT_DEGREE MAX_ENTITIES [-f FLAG ...]

        Example:
            findNetworkByRecordID '{"RECORDS":[{"DATA_SOURCE":"REFERENCE","RECORD_ID":"2071"},{"DATA_SOURCE":"CUSTOMERS","RECORD_ID":"1069"}]}' 6 4 15

        Arguments:
            RECORD_LIST = JSON document listing records to find paths between and networks around
            MAX_DEGREES = Maximum number of relationships to search for a path
            BUILD_OUT_DEGREE = Maximum degree of relationships to include around each entity
            MAX_ENTITIES = Maximum number of entities to return
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.find_network_by_record_id(
                kwargs["parsed_args"].record_list,
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].build_out_degree,
                kwargs["parsed_args"].max_entities,
                kwargs["flags"],
            )
        else:
            response = self.sz_engine.find_network_by_record_id(
                kwargs["parsed_args"].record_list,
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].build_out_degree,
                kwargs["parsed_args"].max_entities,
            )

        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_findPathByEntityID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Find a path between two entities

        Syntax:
            findPathByEntityID START_ENTITY_ID END_ENTITY_ID MAX_DEGREES [-e EXCLUSIONS] [-r REQUIRED_DATA_SOURCES] [-f FLAG ...]

        Example:
            findPathByEntityID 100002 5 3

        Arguments:
            START_ENTITY_ID = Identifier for an entity
            END_ENTITY_ID = Identifier for an entity
            MAX_DEGREES = Maximum number of relationships to search for a path
            EXCLUSIONS = Exclude specified entity IDs or record IDs from the path, default is no exclusions
            REQUIRED_DATA_SOURCES = An entity on the path has specified data source(s), default is no required data sources
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.find_path_by_entity_id(
                kwargs["parsed_args"].start_entity_id,
                kwargs["parsed_args"].end_entity_id,
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].exclusions,
                kwargs["parsed_args"].required_data_sources,
                kwargs["flags"],
            )
        else:
            response = self.sz_engine.find_path_by_entity_id(
                kwargs["parsed_args"].start_entity_id,
                kwargs["parsed_args"].end_entity_id,
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].exclusions,
                kwargs["parsed_args"].required_data_sources,
            )

        self.last_response = self.output_response(response)

    # TODO Wording on exclusions
    @sz_cmds_decorator()
    def do_findPathByRecordID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Find a path between two records

        Syntax:
            findPathByRecordID START_DSRC_CODE START_RECORD_ID END_DSRC_CODE END_RECORD_ID MAX_DEGREES [-e EXCLUSIONS] [-r REQUIRED_DATA_SOURCES] [-f FLAG ...]

        Example:
            findPathByRecordID reference 2141 reference 2121 6

        Arguments:
            START_DSRC_CODE = Data source code
            START_RECORD_ID = Record identifier
            END_DSRC_CODE = Data source code
            END_RECORD_ID = Record identifier
            MAX_DEGREES = Maximum number of relationships to search for a path
            EXCLUSIONS = Exclude specified entity IDs or record IDs from the path, default is no exclusions
            REQUIRED_DATA_SOURCES = An entity on the path has specified data source(s), default is no required data sources
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.find_path_by_record_id(
                kwargs["parsed_args"].start_data_source_code,
                kwargs["parsed_args"].start_record_id,
                kwargs["parsed_args"].end_data_source_code,
                kwargs["parsed_args"].end_record_id,
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].exclusions,
                kwargs["parsed_args"].required_data_sources,
                kwargs["flags"],
            )
        else:
            response = self.sz_engine.find_path_by_record_id(
                kwargs["parsed_args"].start_data_source_code,
                kwargs["parsed_args"].start_record_id,
                kwargs["parsed_args"].end_data_source_code,
                kwargs["parsed_args"].end_record_id,
                kwargs["parsed_args"].max_degrees,
                kwargs["parsed_args"].exclusions,
                kwargs["parsed_args"].required_data_sources,
            )

        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_getActiveConfigID(self) -> None:
        """
        Get the active configuration identifier

        Syntax:
            getActiveConfigID"""

        response = self.sz_engine.get_active_config_id()
        self.last_response = self.output_response(response, color="success")

    @sz_cmds_decorator()
    def do_getEntityByEntityID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Get entity by resolved entity identifier

        Syntax:
            getEntityByEntityID ENTITY_ID [-f FLAG ...]

        Examples:
            getEntityByEntityID 1
            getEntityByEntityID 1 -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_SUMMARY

        Arguments:
            ENTITY_ID = Identifier for an entity
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_entity = functools.partial(
            self.sz_engine.get_entity_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = get_entity(kwargs["flags"]) if "flags" in kwargs else get_entity()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_getEntityByRecordID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Get entity by data source code and record identifier

        Syntax:
            getEntityByRecordID DSRC_CODE RECORD_ID [-f FLAG ...]

        Examples:
        getEntityByRecordID customers 1001
        getEntityByRecordID customers 1001 -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_SUMMARY

        Arguments:
            DSRC_CODE = Data source code
            RECORD_ID = Record identifier
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_entity = functools.partial(
            self.sz_engine.get_entity_by_record_id,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = get_entity(kwargs["flags"]) if "flags" in kwargs else get_entity()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_getRecord(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Get a record

        Syntax:
            getRecord DSRC_CODE RECORD_ID [-f FLAG ...]

        Examples:
            getRecord watchlist 2092
            getRecord watchlist 2092 -f SZ_RECORD_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_FORMATTED_DATA

        Arguments:
            DSRC_CODE = Data source code
            RECORD_ID = Record identifier
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_record = functools.partial(
            self.sz_engine.get_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = get_record(kwargs["flags"]) if "flags" in kwargs else get_record()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_getRedoRecord(self) -> None:
        """
        Get a redo record from the redo queue

        Syntax:
            getRedoRecord"""

        response = self.sz_engine.get_redo_record()
        if not response:
            self.last_response = self.output_response("No redo records.", "info")
        else:
            self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_getStats(self) -> None:
        """
        Get engine workload statistics for last process

        Syntax:
            getStats"""

        response = self.sz_engine.get_stats()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_getVirtualEntityByRecordID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Determine how an entity composed of a given set of records would look

        Syntax:
            getVirtualEntityByRecordID RECORD_LIST[-f FLAG ...]

        Example:
            getVirtualEntityByRecordID '{"RECORDS": [{"DATA_SOURCE": "REFERENCE","RECORD_ID": "2071"},{"DATA_SOURCE": "CUSTOMERS","RECORD_ID": "1069"}]}'

        Arguments:
            RECORD_LIST = JSON document listing data sources and records
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_virtual = functools.partial(
            self.sz_engine.get_virtual_entity_by_record_id,
            kwargs["parsed_args"].record_list,
        )

        response = get_virtual(kwargs["flags"]) if "flags" in kwargs else get_virtual()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_howEntityByEntityID(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Retrieve information on how entities are constructed from their records

        Syntax:
            howEntityByEntityID ENTITY_ID [-f FLAG ...]

        Example:
            howEntityByEntityID 96

        Arguments:
            ENTITY_ID = Identifier for an entity
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        how_entity = functools.partial(
            self.sz_engine.how_entity_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = how_entity(kwargs["flags"]) if "flags" in kwargs else how_entity()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_primeEngine(self) -> None:
        """
        Prime the Senzing engine

        Syntax:
            primeEngine"""

        self.sz_engine.prime_engine()
        self.last_response = self.output_response("Engine primed.", "success")

    @sz_cmds_decorator(cmd_has_args=True)
    def do_processRedoRecord(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Process a redo record fetched from the redo queue

        Syntax:
            processRedoRecord REDO_RECORD [-f FLAG ...]

        Examples:
            processRedoRecord <redo_record>
            processRedoRecord <redo_record> -f SZ_WITH_INFO

        Arguments:
            REDO_RECORD = A redo record
            FLAG = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        process_redo = functools.partial(
            self.sz_engine.process_redo_record,
            kwargs["parsed_args"].redo_record,
        )

        response = process_redo(kwargs["flags"]) if "flags" in kwargs else process_redo()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=True)
    def do_preprocessRecord(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Pre-process a record

        Syntax:
            preprocessRecord RECORD_DEFINITION [-f FLAG ...]

        Examples:
            preprocessRecord '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}'
            preprocessRecord '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}' -f SZ_RECORD_DEFAULT_FLAGS

        Arguments:
            RECORD_DEFINITION = Senzing mapped JSON representation of a record
            FLAG = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        preprocess_record = functools.partial(
            self.sz_engine.preprocess_record,
            kwargs["parsed_args"].record_definition,
        )

        response = preprocess_record(kwargs["flags"]) if "flags" in kwargs else preprocess_record()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_reevaluateEntity(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Reevaluate an entity and optionally return information

        Syntax:
            reevaluateEntity ENTITY_ID [-f FLAG ...]

        Example:
            reevaluateEntity 1

            reevaluateEntity 1 -f SZ_WITH_INFO

        Arguments:
            ENTITY_ID = Entity identifier
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        reevaluate = functools.partial(
            self.sz_engine.reevaluate_entity,
            kwargs["parsed_args"].entity_id,
        )

        response = reevaluate(kwargs["flags"]) if "flags" in kwargs else reevaluate()
        if response == "{}":
            self.last_response = self.output_response("Entity reevaluated", "success")
        else:
            self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_reevaluateRecord(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Reevaluate a record and optionally return information

        Syntax:
            reevaluateRecord DSRC_CODE RECORD_ID [-f FLAG ...]

        Examples:
            reevaluateRecord customers 1001
            reevaluateRecord customers 1001 -f SZ_WITH_INFO

        Arguments:
            DSRC_CODE = Data source code
            RECORD_ID = Record identifier
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        reevaluate = functools.partial(
            self.sz_engine.reevaluate_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = reevaluate(kwargs["flags"]) if "flags" in kwargs else reevaluate()
        if response == "{}":
            self.last_response = self.output_response("Record reevaluated", "success")
        else:
            self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_searchByAttributes(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        # TODO Should search_profile be documented?
        # searchByAttributes ATTRIBUTES [SEARCH_PROFILE] [-f FLAG ...]
        # searchByAttributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}' SEARCH -f SZ_SEARCH_BY_ATTRIBUTES_MINIMAL_ALL
        # SEARCH_PROFILE = Search profile to use (defaults to SEARCH)

        """
        Search for entities

        Syntax:
            searchByAttributes ATTRIBUTES [-f FLAG ...]

        Examples:
            searchByAttributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}'
            searchByAttributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}' -f SZ_SEARCH_BY_ATTRIBUTES_MINIMAL_ALL

        Arguments:
            ATTRIBUTES = Senzing mapped JSON containing the attributes to search on
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.search_by_attributes(
                kwargs["parsed_args"].attributes,
                kwargs["flags"],
                kwargs["parsed_args"].search_profile,
            )
        else:
            response = self.sz_engine.search_by_attributes(
                kwargs["parsed_args"].attributes,
                search_profile=kwargs["parsed_args"].search_profile,
            )

        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_whyEntities(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Determine how entities relate to each other

        Syntax:
            whyEntities ENTITY_ID1 ENTITY_ID2 [-f FLAG ...]

        Examples:
            whyEntities 96 200011
            whyEntities 96 200011 -f SZ_WHY_ENTITY_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_RECORD_DEFINITION

        Arguments:
            ENTITY_ID1 = Identifier for first entity
            ENTITY_ID2 = Identifier for second entity
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        why_entities = functools.partial(
            self.sz_engine.why_entities,
            kwargs["parsed_args"].entity_id1,
            kwargs["parsed_args"].entity_id2,
        )

        response = why_entities(kwargs["flags"]) if "flags" in kwargs else why_entities()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_whyRecordInEntity(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Determine why a particular record resolved to an entity

        Syntax:
            whyRecordInEntity DSRC_CODE RECORD_ID [-f FLAG ...]

        Examples:
            whyRecordInEntity reference 2121
            whyRecordInEntity reference 2121 -f SZ_WHY_ENTITY_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_RECORD_DEFINITION

        Arguments:
            DSRC_CODE = Data source code
            RECORD_ID = Record identifier
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        why_record = functools.partial(
            self.sz_engine.why_record_in_entity,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = why_record(kwargs["flags"]) if "flags" in kwargs else why_record()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator()
    def do_whyRecords(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """
        Determine how two records relate to each other

        Syntax:
            whyRecords DSRC_CODE1 RECORD_ID1 DSRC_CODE2 RECORD_ID1 [-f FLAG ...]

        Examples:
            whyRecords reference 2121 watchlist 2092
            whyRecords reference 2121 watchlist 2092 -f SZ_WHY_ENTITY_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_RECORD_DEFINITION

        Arguments:
            DSRC_CODE1 = Data source code for first record
            DSRC_CODE2 = Data source code for second record
            RECORD_ID1 = Identifier for first record
            RECORD_ID2 = Identifier for second record
            FLAG = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        why_records = functools.partial(
            self.sz_engine.why_records,
            kwargs["parsed_args"].data_source_code1,
            kwargs["parsed_args"].record_id1,
            kwargs["parsed_args"].data_source_code2,
            kwargs["parsed_args"].record_id2,
        )

        response = why_records(kwargs["flags"]) if "flags" in kwargs else why_records()
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # szproduct commands
    # -----------------------------------------------------------------------------

    @sz_cmds_decorator(cmd_has_args=False)
    def do_getLicense(self) -> None:
        """
        Get license information

        Syntax:
            getLicense"""

        response = self.sz_product.get_license()
        self.last_response = self.output_response(response)

    @sz_cmds_decorator(cmd_has_args=False)
    def do_getVersion(self) -> None:
        """
        Get version information

        Syntax:
            getVersion"""

        response = self.sz_product.get_version()
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # Helper commands
    # -----------------------------------------------------------------------------

    def do_hidden(self, _: None) -> None:
        print()
        print("\n".join(map(str, self.__hidden_cmds)))
        print()

    def do_history(self, _: None) -> None:
        """
        Displays the command history

        Syntax:
            history
        """
        do_history()

    def do_json_color(self, _: None) -> None:
        # TODO Add to help this saves to config file and about per cmd changes
        """
        Enables/disables adding colors to JSON responses

        Syntax:
            json_color
        """
        self.color_json = not self.color_json
        print_info(f'Coloring of JSON responses {"enabled" if self.color_json else "disabled"}')

        self.write_config()

    def do_json_format(self, _: None) -> None:
        # TODO Add to help this saves to config file
        """
        Switch output between json (tall json) and jsonl (json lines) for JSON responses

        Syntax:
            json_format
        """
        self.format_json = not self.format_json
        print_info(f'Formatting of JSON responses {"enabled" if self.format_json else "disabled"}')

        self.write_config()

    def do_responseToClipboard(self, _) -> None:  # type: ignore[no-untyped-def]
        """# TODO"""
        response_to_clipboard(self.last_response)

    @sz_cmds_decorator()
    def do_responseToFile(self, **kwargs) -> None:  # type: ignore[no-untyped-def]
        """# TODO"""
        response_to_file(kwargs["parsed_args"].file_path, self.last_response)

    def do_responseReformatJson(self, _) -> None:  # type: ignore[no-untyped-def]
        """# TODO"""
        response_reformat_json(self.last_response, self.color_json, self.format_json)

    def do_scroll_output(self, _: None) -> None:
        # TODO Add to help
        """
        Switch output between using a pager or not

        Syntax:
            scroll_output
        """
        self.scroll_output = not self.scroll_output
        print_info(f'Paging of JSON responses {"enabled" if self.scroll_output else "disabled"}')

        self.write_config()

    @sz_cmds_decorator()
    def do_setTheme(self, **kwargs):  # type: ignore[no-untyped-def]
        """
        Switch terminal ANSI colors

        Syntax:
            setTheme default|dark|light|{terminal}

        Note:
            - The default is terminal and recommended
        """
        Colors.set_theme(kwargs["parsed_args"].theme[0])
        self.theme = kwargs["parsed_args"].theme[0]
        self.write_config()

    def do_timer(self, _: None) -> None:
        """# TODO"""
        self.timer = not self.timer
        print_info(f'Timer {"enabled" if self.timer else "disabled"}')
        self.write_config()

    # -----------------------------------------------------------------------------
    # Helper methods
    # -----------------------------------------------------------------------------

    # Check input command for optional formatters and apply them
    # Remove formatters from input command and return modified input command
    def apply_formats(
        self,
        cmd_line: str,
    ) -> str:
        # Convert command string to a list and lower each element to check
        # Check if there are any formatters on the input command
        cmd_list_lower = [x.lower() for x in cmd_line.split()]
        formats = [f for f in formatters if f in cmd_list_lower]

        # Set formatters if any are found on the input command
        if formats:
            # Input command as a list to remove any formatters
            cmd_list = cmd_line.split()

            for format_ in formats:
                if format_ in ["json", "jsonl"]:
                    self.cmd_format = True
                    if format_ == "json":
                        self.format_json_cmd = True
                    if format_ == "jsonl":
                        self.format_json_cmd = False

                if format_ in [
                    "color",
                    "colour",
                    "nocolor",
                    "nocolour",
                ]:
                    self.cmd_color = True
                    if format_ in ["color", "colour"]:
                        self.color_json_cmd = True
                    if format_ in ["nocolor", "nocolour"]:
                        self.color_json_cmd = False

                # Remove any formatters from input command list
                for a in cmd_list:
                    if a.lower() == format_:
                        cmd_list.remove(a)

            # Return a string of input command with formatters removed
            return " ".join(cmd_list)

        return cmd_line

    # Parses command arguments into a list of argument strings
    def parse(self, argument_string: str) -> List[str]:
        try:
            shlex_list = shlex.split(argument_string)
            return shlex_list
        except ValueError as err:
            print_error(f"Unable to parse arguments: {err}")
            raise

    # Try and read configuration ini file, if one doesn't exist create one
    def read_config(self) -> None:
        config_exists = pathlib.Path(self.config_file).exists()
        read_config = configparser.ConfigParser()

        if config_exists:
            try:
                with open(self.config_file, "r", encoding="utf-8") as _:
                    pass
                read_config.read(self.config_file)
                self.format_json = read_config["CONFIG"].getboolean("formatjson")
                self.color_json = read_config["CONFIG"].getboolean("outputcolor")
                self.timer = read_config["CONFIG"].getboolean("timer")
                self.theme = read_config["CONFIG"]["theme"]
                self.scroll_output = read_config["CONFIG"].getboolean("scrolloutput")
            except IOError as err:
                print_warning(
                    f"Error reading configuration file: {err}",
                )
            except (configparser.Error, KeyError) as err:
                print_warning(
                    f"Error reading entries from configuration file: {err}",
                )
        else:
            # If a configuration file doesn't exist attempt to create one
            self.write_config()

    # Try and write configuration ini file
    def write_config(self) -> None:
        if self.docker_launched:
            return

        write_config = configparser.ConfigParser()
        write_config["CONFIG"] = {
            "formatjson": f'{"True" if self.format_json else "False"}',
            "outputcolor": f'{"True" if self.color_json else "False"}',
            "timer": f'{"True" if self.timer else "False"}',
            "theme": self.theme,
            "scrolloutput": f'{"True" if self.scroll_output else "False"}',
        }

        try:
            with open(self.config_file, "w", encoding="utf-8") as config_file:
                write_config.write(config_file)
        except IOError as err:
            if not self.config_error:
                print_warning(
                    f"Error saving configuration: {err}",
                )
                self.config_error = not self.config_error
        except configparser.Error as err:
            if not self.config_error:
                print_warning(
                    f"Error writing entries to the configuration file: {err}",
                )
                self.config_error = not self.config_error

    # -------------------------------------------------------------------------
    # Auto completers
    # -------------------------------------------------------------------------

    # pylint: disable=unused-argument

    # Auto complete engine flags from self.szengineflags
    def flags_completes(self, text: str, line: str) -> List[str]:
        flags = []
        if re.match(".* -f +", line):
            flags = [flag for flag in self.engine_flags_list if flag.lower().startswith(text.lower())]
        return flags

    # Auto complete engine flags and JSON key/value syntax
    def json_and_flags_completes(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        # Do not change the order of these matches!

        # comp_cmd = re.match(r"\w+ +", line)
        comp_cmd = re.match(r"\w+ +\w+ +\w+ +", line)
        if comp_cmd and len(comp_cmd.group()) == len(line):
            # print(f"{comp_cmd.group() = }")
            return ["""'{"": "", """]

        re_flags = re.search(" -f +.*$", line)
        if re_flags and re_flags.end() == endidx:
            flags = [flag for flag in self.engine_flags_list if flag.lower().startswith(text.lower())]
            return flags

        # re_j_start = re.search("'{{1}", line)
        re_j_start = re.match(r"\w+ +\w+ +\w+ +'{{1}", line)
        if re_j_start:

            # Look ahead a couple of characters...
            attr_check = line[begidx : begidx + 2]

            if re.search("'{", line[begidx:]):
                return []

            if attr_check == '":' or re.match(r"\w", attr_check):
                attrs = [attr for attr in self.attrs if attr.lower().startswith(text.lower())]
                return attrs

            if not text and line[begidx - 1 :] == '"':
                return ["}' "]

            if not text and line[begidx : begidx + 1] not in [
                '"',
                ":",
                " ",
                ",",
                "' ",
                "}",
            ]:
                if not re.search("\"}' *$", line):
                    print(f"{line = }")
                    print(f"{text = }")
                    print(f"begidx: {line[begidx:begidx] = }")
                    print(f"begidx + 1: {line[begidx:begidx+1] = }")
                    print(f"begidx + 2: {line[begidx:begidx+2] = }")
                    print(f"begidx - 1: {line[begidx-1:] = }")
                    print(f"begidx - 2: {line[begidx-2:] = }")
                    print(f"begidx - 3: {line[begidx-3:] = }")
                    print(f"begidx - 4: {line[begidx-4:] = }")
                    return ['"": "", ']

        return []

    @staticmethod
    def path_completes(
        text: str,
        line: str,
        begidx: int,
        endidx: int,
        calling_cmd: str,
    ) -> List[str]:
        """Auto complete paths for commands"""

        completes = []
        path_comp = line[len(calling_cmd) + 1 : endidx]
        fixed = line[len(calling_cmd) + 1 : begidx]
        for path in glob.glob(f"{path_comp}*"):
            path = path + os.sep if path and os.path.isdir(path) and path[-1] != os.sep else path
            completes.append(path.replace(fixed, "", 1))

        return completes

    def complete_addRecord(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.json_and_flags_completes(text, line, begidx, endidx)

    def complete_deleteRecord(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_exportCSVEntityReport(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("exportCSVEntityReport +", line) and not re.match("exportCSVEntityReport +.* +", line):
            return self.path_completes(text, line, begidx, endidx, "exportCSVEntityReport")

        if re.match(".* -f +", line):
            return self.flags_completes(text, line)
        return []

    def complete_exportJSONEntityReport(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("exportJSONEntityReport +", line) and not re.match("exportJSONEntityReport +.* +", line):
            return self.path_completes(text, line, begidx, endidx, "exportJSONEntityReport")

        if re.match(".* -f +", line):
            return self.flags_completes(text, line)
        return []

    def complete_findInterestingEntitiesByEntityID(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_findInterestingEntitiesByRecordID(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_findNetworkByEntityID(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_findNetworkByRecordID(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_findPathByEntityID(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_findPathByRecordID(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_getEntityByEntityID(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_getEntityByRecordID(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_getRecord(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_getVirtualEntityByRecordID(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_howEntityByEntityID(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_preprocessRecord(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.json_and_flags_completes(text, line, begidx, endidx)

    def complete_processRedoRecord(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_reevaluateEntity(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_reevaluateRecord(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_searchByAttributes(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        # return self.flags_completes(text, line)
        return self.json_and_flags_completes(text, line, begidx, endidx)

    def complete_whyRecordInEntity(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_whyEntities(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_responseToFile(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("responseToFile +", line):
            return self.path_completes(text, line, begidx, endidx, "responseToFile")
        return []

    def complete_setTheme(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("setTheme +", line):
            return [theme for theme in self.themes if theme.lower().startswith(text.lower())]
        return []


def get_engine_flags(flags: Union[List[str], List[int]]) -> int:
    """Detect if int or named flags are used and convert to int ready to send to SDK call"""
    print(flags)
    # Support
    if flags[0] == "-1":
        return -1

    # An int is used for the engine flags - old method still supported
    # When using an int there should only be one value
    if isinstance(flags[0], int):
        return flags[0]

    # Named engine flag(s) used, combine and return the int value
    return SzEngineFlags.combine_flags(flags)  # type: ignore


def parse_cli_args() -> argparse.Namespace:
    """# TODO"""
    arg_parser = argparse.ArgumentParser(
        allow_abbrev=False,
        description="Utility to interact with Senzing APIs",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    arg_parser.add_argument(
        "-c",
        "--ini-file",
        help="optional path and file name of G2Module.ini to use",
    )
    # TODO Make mutually exclusive with file    g
    # TODO Add that multiple -C can be used?
    arg_parser.add_argument(
        "-C",
        "--command",
        action="append",
        nargs="*",
        help="run a single command non-interactively",
    )
    arg_parser.add_argument(
        "-f",
        "--file-to-process",
        default=None,
        help="path and file name of file with commands to process",
        nargs="?",
    )
    arg_parser.add_argument(
        "-o",
        "--capture-file",
        help="capture session output to a file",
    )
    arg_parser.add_argument(
        "-t",
        "--debug_trace",
        action="store_true",
        default=False,
        help="output debug information",
    )
    arg_parser.add_argument(
        "-H",
        "--hist_disable",
        action="store_true",
        default=False,
        help="disable use of history file",
    )

    return arg_parser.parse_args()


def main() -> None:
    """main"""

    cli_args = parse_cli_args()

    # Check an engine configuration can be located
    engine_config = get_engine_config(cli_args.ini_file)

    cmd_obj = SzCmdShell(engine_config, cli_args)

    # Execute a single command
    if cli_args.command:
        print(f"\n{cli_args.command = }", flush=True)
        cmd_obj.commands_from_cli(cli_args.command)
        return

    # Execute a file of commands
    if cli_args.file_to_process:
        cmd_obj.commands_from_file(cli_args.file_to_process)
        return

    # Interactive session
    cmd_obj.cmdloop()


if __name__ == "__main__":
    main()
