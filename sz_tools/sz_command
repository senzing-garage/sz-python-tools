#! /usr/bin/env python3

import argparse
import cmd
import functools
import glob
import json
import os
import pathlib
import re
import shlex
import sys
import textwrap
import time
from typing import Any, Callable, Dict, List, TypeVar, Union, cast

from _tool_helpers import (
    Colors,
    colorize_cmd_prompt,
    colorize_output,
    colorize_str,
    do_help,
    do_history,
    do_shell,
    get_engine_config,
    get_engine_flag_names,
    get_engine_flags_as_int,
    history_disabled,
    history_setup,
    in_docker,
    print_debug,
    print_error,
    print_info,
    print_response,
    print_warning,
    response_reformat_json,
    response_to_clipboard,
    response_to_file,
)
from senzing import SzError
from senzing_core import SzAbstractFactoryCore, SzConfigCore

_WrappedFunc = TypeVar("_WrappedFunc", bound=Callable[..., Any])


MODULE_NAME = pathlib.Path(__file__).stem

PER_CMD_SETTINGS = ["json", "jsonl", "color", "colour", "nocolor", "nocolour", "debug", "timer", "scroll"]

DEFAULT_CONFIG = {
    "format_json": True,
    "color_output": True,
    "timer": False,
    "theme": "TERMINAL",
    "scroll_output": False,
    "debug_sdk_call": False,
    "debug_sz_engine": False,
    "history_file": True,
}


# Map per command settings to configuration dictionary keys
SETTINGS_TO_CONFIG_MAP = {
    "json": ["format_json", True],
    "jsonl": ["format_json", False],
    "color": ["color_output", True],
    "colour": ["color_output", True],
    "nocolor": ["color_output", False],
    "nocolour": ["color_output", False],
    "debug": ["debug_sdk_call", True],
    "debug_sdk": ["debug_sdk_call", True],
    "timer": ["timer", True],
    "scroll": ["scroll_output", True],
}

# Don't overwrite last command if we still need to use it
CMDS_NOT_TO_SET_LAST_COMMAND = [
    "response_reformat_json",
    "response_to_clipboard",
    "response_to_file",
]

CONFIG_SETTINGS: Dict[str, Dict[str, Any]] = {
    "format_json": {
        "values": ["off", "on"],
        "description": "Format JSON responses",
    },
    "color_output": {
        "values": ["off", "on"],
        "description": "Color output",
    },
    "timer": {
        "values": ["off", "on"],
        "description": "Display approximate timings for command execution",
    },
    "theme": {
        "values": [c.lower() for c in Colors.AVAILABLE_THEMES],
        "description": "Set color scheme to use",
    },
    "scroll_output": {
        "values": ["off", "on"],
        "description": "Use a pager for content larger than the terminal",
    },
    "debug_sdk_call": {
        "values": ["off", "on"],
        "description": "Display the call sent to the Senzing SDK",
    },
    "debug_sz_engine": {
        "values": ["off", "on"],
        "description": "Display debug tracing from the Senzing engine",
    },
    "history_file": {"values": ["off", "on"], "description": "Use a history file", "value": None},
}


# Due to the way the Cmd module works, don't want doc strings on everything
# pylint: disable=missing-function-docstring


# -------------------------------------------------------------------------
# Decorators
# -------------------------------------------------------------------------


def do_methods_decorator(do_method: _WrappedFunc) -> _WrappedFunc:
    @functools.wraps(do_method)
    def wrapper(self, *args: Any, **kwargs: Any) -> Any:
        # Remove do_ from wrapped method
        sdk_method_name = do_method.__name__[3:]

        # Set the pre command config to handle jsonl, nocolor. etc
        self.set_pre_cmd_settings(args[0])

        # Remove any per cmd line settings such as jsonl, nocolor, etc
        cmd_args = self.remove_per_cmd_settings(args[0])

        do_debug = self.per_cmd_config["debug_sdk_call"]
        do_timer = self.per_cmd_config["timer"]

        if do_debug:
            sdk_engine = ""
            if sdk_method_name in dir(self.sz_config):
                sdk_engine = "SzConfig."
            elif sdk_method_name in dir(self.sz_configmgr):
                sdk_engine = "SzConfigManager."
            elif sdk_method_name in dir(self.sz_diagnostic):
                sdk_engine = "SzDiagnostic."
            elif sdk_method_name in dir(self.sz_engine):
                sdk_engine = "SzEngine."
            elif sdk_method_name in dir(self.sz_product):
                sdk_engine = "SzProduct."

            sdk_call = f"{sdk_engine}{sdk_method_name}"
            sdk_call_dict = {}

        # If there is a parser for the method it takes arguments
        if sdk_method_name in self.subparsers.choices:
            try:
                # Parse arguments for a command and add to kwargs to use in calling do_ method
                # Returns an argparse.Namespace, make a dict for logic checking and less complaints from mypy!
                kwargs["parsed_args"] = self.parser.parse_args([f"{sdk_method_name}"] + self.parse(cmd_args))
                # Get the argparse.Namespace as a dictionary to change any modified arguments for debug
                if do_debug:
                    sdk_call_dict = kwargs["parsed_args"].__dict__.copy()

                # If the command has flags get the int value
                if hasattr(kwargs["parsed_args"], "flags") and kwargs["parsed_args"].flags:
                    kwargs["flags"] = get_engine_flags_as_int(kwargs["parsed_args"].flags)
                    if do_debug:
                        sdk_call_dict["flags"] = kwargs["flags"]

                # If the command uses *record_keys build the expected list of tuples for the SDK
                if hasattr(kwargs["parsed_args"], "record_keys") or hasattr(kwargs["parsed_args"], "avoid_record_keys"):
                    rk_type = "record_keys" if "record_keys" in kwargs["parsed_args"] else "avoid_record_keys"
                    record_keys = getattr(kwargs["parsed_args"], rk_type)
                    # 1 list element == str from quotes: get_virtual_entity_by_record_id 'REFERENCE 2012 customers 1001'
                    # >1 list elements == list such as: find_path_by_record_id ...-a customers 1001 reference 2001
                    # Split single str list element into multiple elements
                    if len(record_keys) == 1:
                        record_keys = record_keys[0].split()

                    if len(record_keys) % 2 != 0:
                        print_error(f"Uneven number of data source codes and record IDs: {record_keys}")
                        return None

                    # Build the list of tuples for the SDK: [('REFERENCE', '2012'), ('CUSTOMERS', '1001')]
                    kwargs[locals()["rk_type"]] = [tuple(record_keys[i : i + 2]) for i in range(0, len(record_keys), 2)]

                    if do_debug:
                        sdk_call_dict[locals()["rk_type"]] = kwargs[locals()["rk_type"]]

                # If the method uses entity_ids build the list for the SDK
                # avoid_entity_ids doesn't need to be checked, it is parsed as a list
                if hasattr(kwargs["parsed_args"], "entity_ids"):
                    entity_ids = kwargs["parsed_args"].entity_ids
                    if len(entity_ids) == 1:
                        entity_ids = entity_ids[0].replace(",", " ")
                        entity_ids = entity_ids.split()

                    try:
                        kwargs["entity_ids"] = [int(i) for i in entity_ids]
                    except ValueError:
                        non_ints = [id for id in entity_ids if not id.isdigit()]
                        print_error(f"Entity IDs should be integers: {', '.join(non_ints)}")
                        return None

                    if do_debug:
                        sdk_call_dict["entity_ids"] = kwargs["entity_ids"]

            # Catch argument errors from parser.parse_args and display the commands help
            # Argparse parser error method is subclassed by SzCommandArgumentParser and displays the error
            except SystemExit:
                self.do_help(do_method.__name__)
                return None
            # Catch parsing errors such as missing single quote around JSON, the error is displayed by parse()
            except ValueError:
                return None
            # Catch errors from methods such as get_engine_flags
            except (KeyError, SzError) as err:
                print_error(err)
                return None

        if do_timer:
            timer_start = time.perf_counter()

        # Run the decorated method passing back kwargs for use in SDK call
        try:
            if do_debug:
                sdk_call_args = ", ".join([f"{k} = {repr(v)}" for k, v in sdk_call_dict.items() if v])
                sdk_call_all = f"{sdk_call}({sdk_call_args})"
                print_debug(sdk_call_all)
            result = do_method(self, **kwargs)
        except (SzError, IOError, ValueError) as err:
            result = None
            print_error(err)
        finally:
            if do_timer:
                exec_time = time.perf_counter() - timer_start
                print_info(f"Approximate execution time (s): {exec_time:.5f}", info_prefix=False)

        return result

    return cast(_WrappedFunc, wrapper)


# -------------------------------------------------------------------------
# Classes
# -------------------------------------------------------------------------
class SzCommandArgumentParser(argparse.ArgumentParser):
    """Subclass ArgumentParser, override error() with custom message"""

    def error(self, message: str) -> None:
        self.exit(
            2,
            print_error(message),
        )


class SzCmdShell(cmd.Cmd):
    """Main Cmd class"""

    def __init__(
        self,
        engine_settings: str,
        # cli_args: argparse.Namespace,
        debug_reinit: Dict[str, bool],
    ):
        super().__init__()

        self.engine_settings = engine_settings
        self.debug_reinit = debug_reinit

        # Configuration file for this tool
        self.config = DEFAULT_CONFIG.copy()
        self.per_cmd_config = DEFAULT_CONFIG.copy()
        self.config_file = pathlib.Path(f"~/.{MODULE_NAME}{'.json'}").expanduser()
        self.config_file_exists = pathlib.Path(self.config_file).exists()

        # Display the can't read/write config message once, not at all in container
        self.config_error = False
        self.docker_launched = in_docker()

        # Read the config file
        if not self.docker_launched and self.config_file_exists:
            self.read_config()

        # Create config file if one doesn't exist and write it again if it exists. read_config() merges DEFAULT_CONFIG
        # with the config file incase new config settings are added to DEFAULT_CONFIG in a new release of the tool
        self.write_config()

        # Acquire Senzing engines and information
        # NOTE Don't change the ordering of the create_*() calls to the factory, for verbose_logging
        verbose_logging = 1 if any([self.debug_reinit["verbose_logging"], self.config["debug_sz_engine"]]) else 0

        try:
            self.sz_factory = SzAbstractFactoryCore(
                MODULE_NAME,
                self.engine_settings,
                verbose_logging=verbose_logging,
            )

            self.sz_engine = self.sz_factory.create_engine()
            self.sz_diagnostic = self.sz_factory.create_diagnostic()
            self.sz_config = SzConfigCore()
            self.sz_configmgr = self.sz_factory.create_configmanager()
            self.sz_product = self.sz_factory.create_product()

            # Collect attributes from configuration
            self.attrs = self.get_config_attr_codes()

            # Get Senzing engine flag names for use in auto completion
            self.engine_flags_list = get_engine_flag_names(["_SZ_WITHOUT_INFO"])
        except SzError as err:
            print_error(err)
            sys.exit(1)

        # If default config ID changes reinitialize
        self.reinitialize = False

        # Could be deprecated, undocumented, not supported, experimental or not relevant
        self.__hidden_cmds = (
            "do_EOF",
            "do_find_interesting_entities_by_entity_id",
            "do_find_interesting_entities_by_record_id",
            "do_get_redo_record",
            "do_get_feature",
            "do_hidden",
            "do_shell",
        )

        # Used to change the theme and for setting cmd prompt, use the default colors set by the terminal
        self.themes = Colors.AVAILABLE_THEMES
        Colors.set_theme("TERMINAL")

        # Cmd module settings
        self.intro = ""
        self.prompt_str = "szcmd"
        self.prompt_color = "info"
        self.prompt = colorize_cmd_prompt(self.prompt_str, self.prompt_color, self.config["color_output"])  # type: ignore[arg-type]

        # Prior response and command for post command functions
        self.last_response = ""
        self.last_command = ""

        # History file
        self.history_file: Union[None, pathlib.Path] = None
        self.history_file_error = False

        # -------------------------------------------------------------------------
        # do_* method parsers
        # -------------------------------------------------------------------------

        self.parser = SzCommandArgumentParser(
            add_help=False,
            prog=MODULE_NAME,
            usage=argparse.SUPPRESS,
        )
        self.subparsers = self.parser.add_subparsers()

        # szconfig parsers

        get_config_parser = self.subparsers.add_parser("get_config", usage=argparse.SUPPRESS)
        get_config_parser.add_argument("config_id", type=int)

        # szconfigmanager parsers

        replace_default_config_id_parser = self.subparsers.add_parser(
            "replace_default_config_id", usage=argparse.SUPPRESS
        )
        replace_default_config_id_parser.add_argument("current_default_config_id", type=int)
        replace_default_config_id_parser.add_argument("new_default_config_id", type=int)

        set_default_config_id_parser = self.subparsers.add_parser("set_default_config_id", usage=argparse.SUPPRESS)
        set_default_config_id_parser.add_argument("config_id", type=int)

        # szdiagnostic parsers

        check_repository_performance_parser = self.subparsers.add_parser(
            "check_repository_performance", usage=argparse.SUPPRESS
        )
        check_repository_performance_parser.add_argument("seconds_to_run", default=3, nargs="?", type=int)

        get_feature_parser = self.subparsers.add_parser("get_feature", usage=argparse.SUPPRESS)
        get_feature_parser.add_argument("featureID", type=int)

        purge_repository_parser = self.subparsers.add_parser("purge_repository", usage=argparse.SUPPRESS)
        purge_repository_parser.add_argument(
            "-FORCEPURGE",
            "--FORCEPURGE",
            action="store_true",
            default=False,
            dest="force_purge",
            required=False,
        )

        # szengine parsers

        add_record_parser = self.subparsers.add_parser("add_record", usage=argparse.SUPPRESS)
        add_record_parser.add_argument("data_source_code")
        add_record_parser.add_argument("record_id")
        add_record_parser.add_argument("record_definition")
        add_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        delete_record_parser = self.subparsers.add_parser("delete_record", usage=argparse.SUPPRESS)
        delete_record_parser.add_argument("data_source_code")
        delete_record_parser.add_argument("record_id")
        delete_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        export_csv_entity_report_parser = self.subparsers.add_parser(
            "export_csv_entity_report", usage=argparse.SUPPRESS
        )
        export_csv_entity_report_parser.add_argument("output_file")
        export_csv_entity_report_parser.add_argument("-f", "--flags", nargs="+", required=False)
        export_csv_entity_report_parser.add_argument("-t", "--csv_column_list", required=False, type=str)

        export_json_entity_report_parser = self.subparsers.add_parser(
            "export_json_entity_report", usage=argparse.SUPPRESS
        )
        export_json_entity_report_parser.add_argument("output_file")
        export_json_entity_report_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_interesting_entities_by_entity_id_parser = self.subparsers.add_parser(
            "find_interesting_entities_by_entity_id", usage=argparse.SUPPRESS
        )
        find_interesting_entities_by_entity_id_parser.add_argument("entity_id", type=int)
        find_interesting_entities_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_interesting_entities_by_record_id_parser = self.subparsers.add_parser(
            "find_interesting_entities_by_record_id", usage=argparse.SUPPRESS
        )
        find_interesting_entities_by_record_id_parser.add_argument("data_source_code")
        find_interesting_entities_by_record_id_parser.add_argument("record_id")
        find_interesting_entities_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_network_by_entity_id_parser = self.subparsers.add_parser(
            "find_network_by_entity_id", usage=argparse.SUPPRESS
        )
        find_network_by_entity_id_parser.add_argument("entity_ids", nargs="+")
        find_network_by_entity_id_parser.add_argument("max_degrees", type=int)
        find_network_by_entity_id_parser.add_argument("build_out_degrees", type=int)
        find_network_by_entity_id_parser.add_argument("build_out_max_entities", type=int)
        find_network_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_network_by_record_id_parser = self.subparsers.add_parser(
            "find_network_by_record_id", usage=argparse.SUPPRESS
        )

        find_network_by_record_id_parser.add_argument("record_keys", nargs="+")
        find_network_by_record_id_parser.add_argument("max_degrees", type=int)
        find_network_by_record_id_parser.add_argument("build_out_degrees", type=int)
        find_network_by_record_id_parser.add_argument("build_out_max_entities", type=int)
        find_network_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_path_by_entity_id_parser = self.subparsers.add_parser("find_path_by_entity_id", usage=argparse.SUPPRESS)
        find_path_by_entity_id_parser.add_argument("start_entity_id", type=int)
        find_path_by_entity_id_parser.add_argument("end_entity_id", type=int)
        find_path_by_entity_id_parser.add_argument("max_degrees", type=int)
        find_path_by_entity_id_parser.add_argument(
            "-a", "--avoid_entity_ids", default=[], nargs="+", required=False, type=int
        )
        find_path_by_entity_id_parser.add_argument(
            "-r",
            "--required_data_sources",
            default=[],
            nargs="+",
            required=False,
        )
        find_path_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_path_by_record_id_parser = self.subparsers.add_parser("find_path_by_record_id", usage=argparse.SUPPRESS)
        find_path_by_record_id_parser.add_argument("start_data_source_code")
        find_path_by_record_id_parser.add_argument("start_record_id")
        find_path_by_record_id_parser.add_argument("end_data_source_code")
        find_path_by_record_id_parser.add_argument("end_record_id")
        find_path_by_record_id_parser.add_argument("max_degrees", type=int)

        find_path_by_record_id_parser.add_argument("-a", "--avoid_record_keys", default=[], nargs="+", required=False)
        find_path_by_record_id_parser.add_argument(
            "-r", "--required_data_sources", default=[], nargs="+", required=False
        )
        find_path_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_entity_by_entity_id_parser = self.subparsers.add_parser("get_entity_by_entity_id", usage=argparse.SUPPRESS)
        get_entity_by_entity_id_parser.add_argument("entity_id", type=int)
        get_entity_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_entity_by_record_id_parser = self.subparsers.add_parser("get_entity_by_record_id", usage=argparse.SUPPRESS)
        get_entity_by_record_id_parser.add_argument("data_source_code")
        get_entity_by_record_id_parser.add_argument("record_id")
        get_entity_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_record_parser = self.subparsers.add_parser("get_record", usage=argparse.SUPPRESS)
        get_record_parser.add_argument("data_source_code")
        get_record_parser.add_argument("record_id")
        get_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_record_preview_parser = self.subparsers.add_parser("get_record_preview", usage=argparse.SUPPRESS)
        get_record_preview_parser.add_argument("record_definition")
        get_record_preview_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_virtual_entity_by_record_id_parser = self.subparsers.add_parser(
            "get_virtual_entity_by_record_id", usage=argparse.SUPPRESS
        )
        get_virtual_entity_by_record_id_parser.add_argument("record_keys", nargs="+")
        get_virtual_entity_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        how_entity_by_entity_id_parser = self.subparsers.add_parser("how_entity_by_entity_id", usage=argparse.SUPPRESS)
        how_entity_by_entity_id_parser.add_argument("entity_id", type=int)
        how_entity_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        process_redo_record_parser = self.subparsers.add_parser("process_redo_record", usage=argparse.SUPPRESS)
        process_redo_record_parser.add_argument("redo_record")
        process_redo_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        reevaluate_entity_parser = self.subparsers.add_parser("reevaluate_entity", usage=argparse.SUPPRESS)
        reevaluate_entity_parser.add_argument("entity_id", type=int)
        reevaluate_entity_parser.add_argument("-f", "--flags", nargs="+", required=False)

        reevaluate_record_parser = self.subparsers.add_parser("reevaluate_record", usage=argparse.SUPPRESS)
        reevaluate_record_parser.add_argument("data_source_code")
        reevaluate_record_parser.add_argument("record_id")
        reevaluate_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        search_by_attributes_parser = self.subparsers.add_parser("search_by_attributes", usage=argparse.SUPPRESS)
        search_by_attributes_parser.add_argument("attributes")
        search_by_attributes_parser.add_argument("search_profile", default="SEARCH", nargs="?", type=str.upper)
        search_by_attributes_parser.add_argument("-f", "--flags", nargs="+", required=False)

        why_entities_parser = self.subparsers.add_parser("why_entities", usage=argparse.SUPPRESS)
        why_entities_parser.add_argument("entity_id_1", type=int)
        why_entities_parser.add_argument("entity_id_2", type=int)
        why_entities_parser.add_argument("-f", "--flags", nargs="+", required=False)

        why_record_in_entity_parser = self.subparsers.add_parser("why_record_in_entity", usage=argparse.SUPPRESS)
        why_record_in_entity_parser.add_argument("data_source_code")
        why_record_in_entity_parser.add_argument("record_id")
        why_record_in_entity_parser.add_argument("-f", "--flags", nargs="+", required=False)

        why_records_parser = self.subparsers.add_parser("why_records", usage=argparse.SUPPRESS)
        why_records_parser.add_argument("data_source_code_1")
        why_records_parser.add_argument("record_id_1")
        why_records_parser.add_argument("data_source_code_2")
        why_records_parser.add_argument("record_id_2")
        why_records_parser.add_argument("-f", "--flags", nargs="+", required=False)

        why_search_parser = self.subparsers.add_parser("why_search", usage=argparse.SUPPRESS)
        why_search_parser.add_argument("attributes")
        why_search_parser.add_argument("entity_id", type=int)
        why_search_parser.add_argument("search_profile", default="SEARCH", nargs="?", type=str.upper)
        why_search_parser.add_argument("-f", "--flags", nargs="+", required=False)

        # Utility parsers

        response_to_file_parser = self.subparsers.add_parser("response_to_file", usage=argparse.SUPPRESS)
        response_to_file_parser.add_argument("file_path")
        response_to_file_parser.add_argument(
            "-a", "--append", action="store_true", default=False, dest="append_to_file", required=False
        )
        response_to_file_parser.add_argument(
            "-c", "--command", action="store_true", default=False, dest="add_command", required=False
        )

        set_theme_parser = self.subparsers.add_parser("set_theme", usage=argparse.SUPPRESS)
        set_theme_parser.add_argument("theme", choices=self.themes, nargs=1)

    def get_config_attr_codes(self) -> List[str]:
        try:
            config_id = self.sz_engine.get_active_config_id()
            sz_config = self.sz_configmgr.create_config_from_config_id(config_id)
            config_json = json.loads(sz_config.export())
            cfg_attr = config_json["G2_CONFIG"]["CFG_ATTR"]
            attr_codes = [attr["ATTR_CODE"] for attr in cfg_attr if attr["INTERNAL"].lower() == "no"]
        except (SzError, json.JSONDecodeError):
            attr_codes = []

        return attr_codes

    # Call helper function to format and print command responses with constant values
    def output_response(self, response: Union[int, str], color: str = "") -> str:
        formatted_response: str = print_response(
            response,
            self.per_cmd_config["format_json"],  # type: ignore[arg-type]
            self.per_cmd_config["scroll_output"],  # type: ignore[arg-type]
            self.per_cmd_config["color_output"],  # type: ignore[arg-type]
            color=color,
        )

        return formatted_response

    # -------------------------------------------------------------------------
    # Cmd module methods
    # -------------------------------------------------------------------------

    # Override function from cmd module to make command completion case-insensitive
    def completenames(self, text: str, *ignored: Any) -> List[str]:
        do_text = "do_" + text
        return [a[3:] for a in self.get_names() if a.lower().startswith(do_text.lower())]

    def do_exit(self, _) -> bool:  # type: ignore[no-untyped-def]
        self.do_quit(_)
        return True

    @staticmethod
    def do_quit(_) -> bool:  # type: ignore[no-untyped-def]  # pylint: disable=unused-argument
        return True

    def do_shell(self, line: str) -> None:
        do_shell(self, line)

    # Handle unknown commands
    def default(self, line: str) -> None:
        print_warning("Unknown command, type help or ?")

    # Do nothing if line is empty
    def emptyline(self) -> bool:
        return False

    # Override in cmd module to return methods for autocomplete and help
    # ignoring any hidden commands
    def get_names(self, include_hidden: bool = False) -> List[str]:
        if not include_hidden:
            return [n for n in dir(self.__class__) if n not in self.__hidden_cmds]

        return list(dir(self.__class__))

    def postcmd(self, stop: bool, line: str) -> bool:
        # If do_set() turned on engine verbose logging, exit and reinitialize everything
        if self.debug_reinit["reinitialize"]:
            del self.sz_factory
            return True

        # Update last_command
        if line and not line.startswith("!") and line.split()[0] not in CMDS_NOT_TO_SET_LAST_COMMAND:
            self.last_command = self.remove_per_cmd_settings(line)

        # Default configuration ID was changed by set_default_config_id or replace_default_config_id, sz_command
        # doesn't modify the configuration so reinitialize. Update attributes from the new default configuration
        # for auto-completion
        if self.reinitialize:
            print_info("Default configuration ID has changed, reinitializing...", info_prefix=False)
            try:
                config_id = self.sz_configmgr.get_default_config_id()
                self.sz_factory.reinitialize(config_id)
                self.reinitialize = False
            except SzError as err:
                print_error(err)
                sys.exit(1)

            self.attrs = self.get_config_attr_codes()

        return cmd.Cmd.postcmd(self, stop, line)

    def preloop(self) -> None:
        # Setup history file use if settings are enabled
        if self.config["history_file"]:
            self.enable_history()

        if self.debug_reinit["prior_instance_reinitialized"]:
            print_response("Senzing engines were reinitialized due to a configuration change", color="success")
        else:
            print_info(f"Type help or ? for help", info_prefix=False)

    # -------------------------------------------------------------------------
    # Non-interactive input methods
    # -------------------------------------------------------------------------

    def commands_from_cli(self, commands: List[List[str]]) -> None:
        """
        Run command(s) from the command line, here could be multiple commands and associated arguments in
        commands[]. Command formatters (jsonl, json, etc) are permitted and are handled by sz_cmds_decorator
        """
        number_of_commands = len(commands)
        for each_cmd in commands:
            requested_cmd = each_cmd[0]

            # Build a new list without the requested command resulting in any arguments for the command
            # Due to the way argparse builds the list with the -C argument, also repr() a list item (command argument)
            # if it looks like JSON otherwise the single quotes around the JSON are lost and characters such as space
            # in the JSON string break parsing in the do_* methods
            requested_args = [
                repr(i) if i.strip().startswith("{") and i.strip().endswith("}") else i
                for i in each_cmd
                if i != requested_cmd
            ]

            # Turn the arguments back into a single string for further parsing and call the requested command
            try:
                if number_of_commands > 1:
                    print(f"\n----- {' '.join(each_cmd)} -----")
                cmd_args = " ".join(requested_args)
                self.onecmd(f"{requested_cmd} {cmd_args}")
            except (ValueError, TypeError) as err:
                print_error(f"Problem with command: {err}")

    def commands_from_file(self, file_name: str) -> None:
        """
        Read commands from a file and call the matching commands. Command formatters (jsonl, json, etc) are
        permitted and are handled by sz_cmds_decorator
        """
        try:
            with open(file_name, encoding="utf-8") as cmds_file:
                for each_cmd in cmds_file:
                    each_cmd = each_cmd.strip()
                    # Skip blank lines and comment prefixes
                    if not each_cmd or each_cmd[0:1] in ("#", "-", "/"):
                        continue

                    (requested_cmd, *requested_args) = each_cmd.split()

                    try:
                        cmd_args = " ".join(requested_args)
                        print(f"\n----- {each_cmd} -----")
                        self.onecmd(f"{requested_cmd} {cmd_args}")
                    except (ValueError, TypeError) as err:
                        print_error(f"Problem with command: {err}")
        except OSError as err:
            print_error(err)

    # -------------------------------------------------------------------------
    # Custom help
    # -------------------------------------------------------------------------

    def do_help(self, arg: str = "") -> None:
        do_help(self, arg)

    def help_all(self) -> None:
        self.do_help()

    @staticmethod
    def help_overview() -> None:
        print(
            textwrap.dedent(
                f"""
        {colorize_str('This utility allows you to interact with the Senzing SDK', 'dim')}

        {colorize_str('Help', 'highlight2')}
            {colorize_str('- View help for a command:', 'dim')} help COMMAND
            {colorize_str('- View all commands:', 'dim')} help all

        {colorize_str('Tab Completion', 'highlight2')}
            {colorize_str('- Tab completion is available for commands, files, engine flags, etc', 'dim')}
            {colorize_str('- Hit tab on a blank line to see all commands', 'dim')}

        {colorize_str('JSON Formatting', 'highlight2')}
            {colorize_str('- Change JSON formatting by adding "json" or "jsonl" to the end of a command', 'dim')}
                - get_entity_by_entity_id 1001 jsonl

            {colorize_str('- Can be combined with color formatting options', 'dim')}
                - get_entity_by_entity_id 1001 jsonl nocolor

            {colorize_str('- Convert last response output between json and jsonl', 'dim')}
                - response_reformat_json

        {colorize_str('Color Formatting', 'highlight2')}
            {colorize_str('- Add or remove colors from JSON formatting by adding "color", "colour", "nocolor" or "nocolour" to the end of a command', 'dim')}
                - get_entity_by_entity_id 1001 color

            {colorize_str('- Can be combined with JSON formatting options', 'dim')}
                - get_entity_by_entity_id 1001 color jsonl

        {colorize_str('Capturing Output', 'highlight2')}
            {colorize_str('- Capture the last response output to a file or the clipboard', 'dim')}
                - response_to_clipboard
                - response_to_file /tmp/myoutput.json

        {colorize_str('Configuration', 'highlight2')}
            {colorize_str('- Configuration options are stored in a configuration file', 'dim')}
            {colorize_str('- To see the current configuration or to change it use the set command', 'dim')}
                - set
                - set format_json off

            {colorize_str('- The current configuration can be modified on a per command basis', 'dim')}
            {colorize_str('- Per command configuration settings only affect that command', 'dim')}
            {colorize_str('- See the output from the set command for descriptions of the settings', 'dim')}
            {colorize_str('- The available per command settings are:', 'dim')}
                - json
                - jsonl
                - color / colour
                - nocolor / nocolour
                - debug
                - timer
                - scroll

            {colorize_str('- Examples:', 'dim')}
                - get_entity_by_entity_id 1001 jsonl
                - get_entity_by_entity_id 1001 jsonl nocolor
                - get_entity_by_entity_id 1001 jsonl nocolor timer debug


        {colorize_str('History', 'highlight2')}
            {colorize_str('- Arrow keys to cycle through history of commands', 'dim')}
            {colorize_str('- Ctrl-r can be used to search history', 'dim')}
            {colorize_str('- Display history:', 'dim')} history

        {colorize_str('Shell', 'highlight2')}
            {colorize_str('- Run basic OS shell commands', 'dim')}
                - ! ls

        {colorize_str('Support', 'highlight2')}
            {colorize_str('- Senzing Support:', 'dim')} {colorize_str('https://senzing.zendesk.com/hc/en-us/requests/new', 'highlight1,underline')}
            {colorize_str('- Senzing Knowledge Center:', 'dim')} {colorize_str('https://senzing.zendesk.com/hc/en-us', 'highlight1,underline')}
            {colorize_str('- SDK Docs:', 'dim')} {colorize_str('https://docs.senzing.com', 'highlight1,underline')}

        """
            )
        )

    # -----------------------------------------------------------------------------
    # szconfig commands
    # -----------------------------------------------------------------------------

    @do_methods_decorator
    def do_get_template_config(self) -> None:
        """
        Get a template configuration

        Syntax:
            get_template_config

        """
        sz_config = self.sz_configmgr.create_config_from_template()
        response = sz_config.export()
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # szconfigmanager commands
    # -----------------------------------------------------------------------------

    @do_methods_decorator
    def do_get_config(self, **kwargs: Any) -> None:
        """
        Get a configuration

        Syntax:
            get_config config_id

        Example:
            get_config 4180061352

        Arguments:
            config_id = Configuration identifier

        Notes:
            - Retrieve the active configuration identifier with get_active_config_id

            - Retrieve a list of configurations and identifiers with get_config_registry"""

        sz_config = self.sz_configmgr.create_config_from_config_id(kwargs["parsed_args"].config_id)
        response = sz_config.export()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_config_registry(self) -> None:
        """
        Get details of current registered configurations

        Syntax:
            get_config_registry"""

        response = self.sz_configmgr.get_config_registry()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_default_config_id(self) -> None:
        """
        Get the default configuration ID

        Syntax:
            get_default_config_id"""

        response = self.sz_configmgr.get_default_config_id()
        self.last_response = self.output_response(response, "success")

    @do_methods_decorator
    def do_replace_default_config_id(self, **kwargs: Any) -> None:
        """
        Replace the default configuration ID

        Syntax:
            replace_default_config_id current_default_config_id new_default_config_id

        Example:
            replace_default_config_id 4180061352 2787925967

        Arguments:
            current_default_config_id = Configuration identifier
            new_default_config_id = Configuration identifier

        Notes:
            - Retrieve a list of configurations and identifiers with get_config_registry"""

        self.sz_configmgr.replace_default_config_id(
            kwargs["parsed_args"].current_default_config_id,
            kwargs["parsed_args"].new_default_config_id,
        )
        self.output_response("Default config ID replaced", "success")
        self.reinitialize = True

    @do_methods_decorator
    def do_set_default_config_id(self, **kwargs: Any) -> None:
        """
        Set the default configuration ID

        Syntax:
            set_default_config_id config_id

        Example:
            set_default_config_id 4180061352

        Arguments:
            config_id = Configuration identifier

        Notes:
            - Retrieve a list of configurations and identifiers with get_configList"""

        self.sz_configmgr.set_default_config_id(kwargs["parsed_args"].config_id)
        self.output_response("Default config ID set", "success")
        self.reinitialize = True

    # -----------------------------------------------------------------------------
    # szdiagnostic commands
    # -----------------------------------------------------------------------------

    @do_methods_decorator
    def do_check_repository_performance(self, **kwargs: Any) -> None:
        """
        Run a performance check on the repository

        Syntax:
            check_repository_performance [seconds_to_run]
            check_repository_performance

        Arguments:
            seconds_to_run = Time in seconds to run the check, default is 3"""

        response = self.sz_diagnostic.check_repository_performance(kwargs["parsed_args"].seconds_to_run)
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_repository_info(self) -> None:
        """
        Get repository information

        Syntax:
            get_repository_info"""

        response = self.sz_diagnostic.get_repository_info()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_feature(self, **kwargs: Any) -> None:
        """
        Get feature information

        Syntax:
            get_feature feature_id

        Examples:
            get_feature 1

        Arguments:
            feature_id = Identifier of feature"""

        response = self.sz_diagnostic.get_feature(kwargs["parsed_args"].featureID)
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_purge_repository(self, **kwargs: Any) -> None:
        """
        Purge Senzing database of all data

        Syntax:
            purge_repository [--FORCEPURGE]

        Example:
            purge_repository

        Arguments:
            --FORCEPURGE = Don't prompt before purging. USE WITH CAUTION!

        Caution:
            - This deletes all data in the Senzing database!"""

        purge_msg = colorize_output(
            textwrap.dedent(
                """

                ********** WARNING **********

                This will purge all currently loaded data from the senzing database!
                Before proceeding, all instances of senzing (custom code, rest api, redoer, etc.) must be shut down.

                ********** WARNING **********

                Are you sure you want to purge the Senzing database? Type YESPURGESENZING to purge: """
            ),
            "warning",
        )

        if not kwargs["parsed_args"].force_purge:
            if input(purge_msg) != "YESPURGESENZING":
                print("\nSenzing repository not purged\n")
                return

        self.sz_diagnostic.purge_repository()
        print("\nSenzing repository purged\n")

    # -----------------------------------------------------------------------------
    # szengine commands
    # -----------------------------------------------------------------------------

    @do_methods_decorator
    def do_add_record(self, **kwargs: Any) -> None:
        """
        Add a record and optionally return information

        Syntax:
            add_record dsrc_source_code record_id record_definition [-f flag ...]

        Examples:
            add_record test 1 '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}'
            add_record test 1 '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}' -f SZ_WITH_INFO

        Arguments:
            dsrc_source_code = Data source code
            record_id = Record identifier
            record_definition = Senzing mapped JSON representation of a record
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """
        add_record = functools.partial(
            self.sz_engine.add_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
            kwargs["parsed_args"].record_definition,
        )

        response = add_record(kwargs["flags"]) if "flags" in kwargs else add_record()

        if not response:
            self.last_response = self.output_response("Record added", "success")
        else:
            self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_count_redo_records(self) -> None:
        """
        Counts the number of records in the redo queue

        Syntax:
            count_redo_records"""

        response = self.sz_engine.count_redo_records()
        if not response:
            self.last_response = self.output_response("No redo records", "info")
        else:
            self.last_response = self.output_response(response, "success")

    @do_methods_decorator
    def do_delete_record(self, **kwargs: Any) -> None:
        """
        Delete a record and optionally return information

        Syntax:
            delete_record data_source_code record_id [-f flag ...]

        Examples:
            delete_record test 1
            delete_record test 1 -f SZ_WITH_INFO

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        delete_record = functools.partial(
            self.sz_engine.delete_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = delete_record(kwargs["flags"]) if "flags" in kwargs else delete_record()

        if not response:
            self.last_response = self.output_response("Record deleted.", "success")
        else:
            self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_export_csv_entity_report(self, **kwargs: Any) -> None:
        """
        Export repository contents as CSV

        Syntax:
            export_csv_entity_report output_file [-t csv_column_list,...] [-f flag ...]

        Examples:
            export_csv_entity_report export.csv
            export_csv_entity_report export.csv -t RESOLVED_ENTITY_ID,RELATED_ENTITY_ID,MATCH_LEVEL,MATCH_KEY,DATA_SOURCE,RECORD_ID
            export_csv_entity_report export.csv -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_EXPORT_INCLUDE_ALL_ENTITIES

        Arguments:
            output_file = File to save export to
            csv_column_list = Comma separated list of output columns (don't specify for defaults)
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Available csv_column_list columns
                - RESOLVED_ENTITY_ID,RELATED_ENTITY_ID,MATCH_LEVEL,MATCH_KEY,DATA_SOURCE,RECORD_ID,RESOLVED_ENTITY_NAME,ERRULE_CODE,JSON_DATA

            - Engine flag details https://senzing.com/v4-sdk-flags/

        Caution:
            - Export isn't intended for exporting large numbers of entities and associated data source record information.
              Beyond 100M+ data source records isn't suggested. For exporting overview entity and relationship data for
              analytical purposes outside of Senzing please review the following article.

              https://senzing.com/v4-replicating-to-data-warehouse/
        """
        rec_cnt = 0

        export_csv = functools.partial(
            self.sz_engine.export_csv_entity_report,
            kwargs["parsed_args"].csv_column_list,
        )

        try:
            export_handle = export_csv(kwargs["flags"]) if "flags" in kwargs else export_csv()

            with open(kwargs["parsed_args"].output_file, "w", encoding="utf-8") as csv_out:
                while True:
                    export_record = self.sz_engine.fetch_next(export_handle)
                    if not export_record:
                        break
                    csv_out.write(export_record)
                    rec_cnt += 1
                    if rec_cnt % 1000 == 0:
                        print(f"Exported {rec_cnt} records...", flush=True)
                self.sz_engine.close_export_report(export_handle)
        except (SzError, IOError) as err:
            print_error(err)
        else:
            self.output_response(f"Total exported records: {rec_cnt}", "success")

    @do_methods_decorator
    def do_export_json_entity_report(self, **kwargs: Any) -> None:
        """
        Export repository contents as JSON

        Syntax:
            export_json_entity_report output_file [-f flag ...]

        Examples:
            export_json_entity_report export.json
            export_json_entity_report export.json -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_EXPORT_INCLUDE_ALL_ENTITIES

        Arguments:
            output_file = File to save export to
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/

        Caution:
            - Export isn't intended for exporting large numbers of entities and associated data source record information.
              Beyond 100M+ data source records isn't suggested. For exporting overview entity and relationship data for
              analytical purposes outside of Senzing please review the following article.

              https://senzing.com/v4-replicating-to-data-warehouse/
        """

        rec_cnt = 0

        export_json = functools.partial(
            self.sz_engine.export_json_entity_report,
        )

        try:
            export_handle = export_json(kwargs["flags"]) if "flags" in kwargs else export_json()
            with open(kwargs["parsed_args"].output_file, "w", encoding="utf-8") as data_out:
                while True:
                    export_record = self.sz_engine.fetch_next(export_handle)
                    if not export_record:
                        break
                    data_out.write(export_record)
                    rec_cnt += 1
                    if rec_cnt % 1000 == 0:
                        print(f"Exported {rec_cnt} records...", flush=True)
                self.sz_engine.close_export_report(export_handle)
        except (SzError, IOError) as err:
            print_error(err)
        else:
            self.output_response(f"Total exported records: {rec_cnt}", "success")

    @do_methods_decorator
    def do_find_interesting_entities_by_entity_id(self, **kwargs: Any) -> None:
        """
        Find interesting entities close to an entity by resolved entity identifier

        Syntax:
            find_interesting_entities_by_entity_id entity_id [-f flag ...]

        Example:
            find_interesting_entities_by_entity_id 1

        Arguments:
            entity_id = Identifier for an entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/

            - Experimental feature requires additional configuration, contact support@senzing.com
        """

        find_interesting_entities_by_entity_id = functools.partial(
            self.sz_engine.find_interesting_entities_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = (
            find_interesting_entities_by_entity_id(kwargs["flags"])
            if "flags" in kwargs
            else find_interesting_entities_by_entity_id()
        )

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_find_interesting_entities_by_record_id(self, **kwargs: Any) -> None:
        """
        Find interesting entities close to an entity by record identifier

        Syntax:
            find_interesting_entities_by_record_id data_source_code record_id [-f flag ...]

        Example:
            find_interesting_entities_by_record_id customers 1001

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/

            - Experimental feature requires additional configuration, contact support@senzing.com
        """

        find_interesting_entities_by_record_id = functools.partial(
            self.sz_engine.find_interesting_entities_by_record_id,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = (
            find_interesting_entities_by_record_id(kwargs["flags"])
            if "flags" in kwargs
            else find_interesting_entities_by_record_id()
        )

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_find_network_by_entity_id(self, **kwargs: Any) -> None:
        """
        Find network between entities

        Syntax:
            find_network_by_entity_id entity_ids max_degrees build_out_degrees build_out_max_entities [-f flag ...]

        Example:
            find_network_by_entity_id '1 6 9' 4 3 20

        Arguments:
            entity_ids = List of entities to find paths between and networks around (NOTE: quotes around ENTITY_IDS)
            max_degrees = Maximum number of relationships to search for a path
            build_out_degrees = Maximum degree of relationships to include around each entity
            build_out_max_entities = Maximum number of entities to return
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        find_network_by_entity_id = functools.partial(
            self.sz_engine.find_network_by_entity_id,
            kwargs["entity_ids"],
            kwargs["parsed_args"].max_degrees,
            kwargs["parsed_args"].build_out_degrees,
            kwargs["parsed_args"].build_out_max_entities,
        )

        response = find_network_by_entity_id(kwargs["flags"]) if "flags" in kwargs else find_network_by_entity_id()

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_find_network_by_record_id(self, **kwargs: Any) -> None:
        """
        Find network between records

        Syntax:
            find_network_by_record_id record_keys max_degrees build_out_degrees build_out_max_entities [-f flag ...]

        Example:
            find_network_by_record_id 'REFERENCE 2012 CUSTOMERS 1001' 6 4 15

        Arguments:
            record_keys = List of datasource codes and record ID pairs to find paths between and networks around (NOTE: quotes around RECORD_KEYS)
            max_degrees = Maximum number of relationships to search for a path
            build_out_degrees = Maximum degree of relationships to include around each entity
            build_out_max_entities = Maximum number of entities to return
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        find_network_by_record_id = functools.partial(
            self.sz_engine.find_network_by_record_id,
            kwargs["record_keys"],
            kwargs["parsed_args"].max_degrees,
            kwargs["parsed_args"].build_out_degrees,
            kwargs["parsed_args"].build_out_max_entities,
        )

        response = find_network_by_record_id(kwargs["flags"]) if "flags" in kwargs else find_network_by_record_id()

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_find_path_by_entity_id(self, **kwargs: Any) -> None:
        """
        Find a path between two entities

        Syntax:
            find_path_by_entity_id start_entity_id end_entity_id max_degrees [-a avoid_entity_ids] [-r required_data_sources] [-f flag ...]

        Example:
            find_path_by_entity_id 100002 5 3
            find_path_by_entity_id 100002 5 3 -a 259 10
            find_path_by_entity_id 100002 5 3 -a 259 10 -r WATCHLIST

        Arguments:
            start_entity_id = Identifier for an entity
            end_entity_id = Identifier for an entity
            max_degrees = Maximum number of relationships to search for a path
            avoid_entity_ids = Space separated list of entity ID(s) to avoid when finding the path, default is no avoidance
            required_data_sources = Space separated list of data source(s) an entity on the path should have, default is no required data sources
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        find_path_by_entity_id = functools.partial(
            self.sz_engine.find_path_by_entity_id,
            kwargs["parsed_args"].start_entity_id,
            kwargs["parsed_args"].end_entity_id,
            kwargs["parsed_args"].max_degrees,
            kwargs["parsed_args"].avoid_entity_ids,
            kwargs["parsed_args"].required_data_sources,
        )

        response = find_path_by_entity_id(kwargs["flags"]) if "flags" in kwargs else find_path_by_entity_id()

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_find_path_by_record_id(self, **kwargs: Any) -> None:
        """
        Find a path between two records

        Syntax:
            find_path_by_record_id start_dsrc_code start_record_id end_dsrc_code end_record_id max_degrees [-a avoid_record_keys] [-r required_data_sources] [-f flag ...]

        Example:
            find_path_by_record_id reference 2141 reference 2121 6

        Arguments:
            start_dsrc_code = Data source code
            start_record_id = Record identifier
            end_dsrc_code = Data source code
            end_record_id = Record identifier
            max_degrees = Maximum number of relationships to search for a path
            avoid_record_keys = Space separated list of data source code and record IDs to avoid when finding the path, default is no avoidance
            required_data_sources = Space separated list of data source(s) an entity on the path should have, default is no required data sources
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        find_path_by_record_id = functools.partial(
            self.sz_engine.find_path_by_record_id,
            kwargs["parsed_args"].start_data_source_code,
            kwargs["parsed_args"].start_record_id,
            kwargs["parsed_args"].end_data_source_code,
            kwargs["parsed_args"].end_record_id,
            kwargs["parsed_args"].max_degrees,
            kwargs["avoid_record_keys"],
            kwargs["parsed_args"].required_data_sources,
        )

        response = find_path_by_record_id(kwargs["flags"]) if "flags" in kwargs else find_path_by_record_id()

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_active_config_id(self) -> None:
        """
        Get the active configuration identifier

        Syntax:
            get_active_config_id"""

        response = self.sz_engine.get_active_config_id()
        self.last_response = self.output_response(response, color="success")

    @do_methods_decorator
    def do_get_entity_by_entity_id(self, **kwargs: Any) -> None:
        """
        Get entity by resolved entity identifier

        Syntax:
            get_entity_by_entity_id entity_id [-f flag ...]

        Examples:
            get_entity_by_entity_id 1
            get_entity_by_entity_id 1 -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_SUMMARY

        Arguments:
            entity_id = Identifier for an entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        get_entity = functools.partial(
            self.sz_engine.get_entity_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = get_entity(kwargs["flags"]) if "flags" in kwargs else get_entity()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_entity_by_record_id(self, **kwargs: Any) -> None:
        """
        Get entity by data source code and record identifier

        Syntax:
            get_entity_by_record_id data_source_code record_id [-f flag ...]

        Examples:
        get_entity_by_record_id customers 1001
        get_entity_by_record_id customers 1001 -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_SUMMARY

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        get_entity = functools.partial(
            self.sz_engine.get_entity_by_record_id,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = get_entity(kwargs["flags"]) if "flags" in kwargs else get_entity()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_record(self, **kwargs: Any) -> None:
        """
        Get a record

        Syntax:
            get_record data_source_code record_id [-f flag ...]

        Examples:
            get_record watchlist 2092
            get_record watchlist 2092 -f SZ_RECORD_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_FORMATTED_DATA

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        get_record = functools.partial(
            self.sz_engine.get_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = get_record(kwargs["flags"]) if "flags" in kwargs else get_record()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_record_preview(self, **kwargs: Any) -> None:
        """
        Describe the features resulting from the hypothetical load of a record

        Syntax:
            get_record_preview record_definition [-f flag ...]

        Examples:
            get_record_preview '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}'

        Arguments:
            record_definition = Senzing mapped JSON representation of a record
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        preview_record = functools.partial(self.sz_engine.get_record_preview, kwargs["parsed_args"].record_definition)

        response = preview_record(kwargs["flags"]) if "flags" in kwargs else preview_record()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_redo_record(self) -> None:
        """
        Get a redo record from the redo queue

        Syntax:
            get_redo_record"""

        response = self.sz_engine.get_redo_record()
        if not response:
            self.last_response = self.output_response("No redo records.", "info")
        else:
            self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_stats(self) -> None:
        """
        Get engine workload statistics for last process

        Syntax:
            get_stats"""

        response = self.sz_engine.get_stats()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_virtual_entity_by_record_id(self, **kwargs: Any) -> None:
        """
        Determine how an entity composed of a given set of records would look

        Syntax:
            get_virtual_entity_by_record_id record_keys [-f FLAG ...]

        Example:
            get_virtual_entity_by_record_id 'REFERENCE 2071 CUSTOMERS 1069'

        Arguments:
            record_keys = List of datasource codes and record ID pairs to find paths between and networks around (NOTE: quotes around RECORD_KEYS)
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        get_virtual = functools.partial(
            self.sz_engine.get_virtual_entity_by_record_id,
            kwargs["record_keys"],
        )

        response = get_virtual(kwargs["flags"]) if "flags" in kwargs else get_virtual()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_how_entity_by_entity_id(self, **kwargs: Any) -> None:
        """
        Retrieve information on how entities are constructed from their records

        Syntax:
            how_entity_by_entity_id entity_id [-f flag ...]

        Example:
            how_entity_by_entity_id 96

        Arguments:
            entity_id = Identifier for an entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        how_entity = functools.partial(
            self.sz_engine.how_entity_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = how_entity(kwargs["flags"]) if "flags" in kwargs else how_entity()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_prime_engine(self) -> None:
        """
        Prime the Senzing engine

        Syntax:
            prime_engine"""

        self.sz_engine.prime_engine()
        self.last_response = self.output_response("Engine primed.", "success")

    @do_methods_decorator
    def do_process_redo_record(self, **kwargs: Any) -> None:
        """
        Process a redo record fetched from the redo queue

        Syntax:
            process_redo_record redo_record [-f FLAG ...]

        Examples:
            process_redo_record <redo_record>
            process_redo_record <redo_record> -f SZ_WITH_INFO

        Arguments:
            redo_record = A redo record
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        process_redo = functools.partial(
            self.sz_engine.process_redo_record,
            kwargs["parsed_args"].redo_record,
        )

        response = process_redo(kwargs["flags"]) if "flags" in kwargs else process_redo()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_reevaluate_entity(self, **kwargs: Any) -> None:
        """
        Reevaluate an entity and optionally return information

        Syntax:
            reevaluate_entity entity_id [-f FLAG ...]

        Example:
            reevaluate_entity 1

            reevaluate_entity 1 -f SZ_WITH_INFO

        Arguments:
            entity_id = Entity identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        reevaluate = functools.partial(
            self.sz_engine.reevaluate_entity,
            kwargs["parsed_args"].entity_id,
        )

        response = reevaluate(kwargs["flags"]) if "flags" in kwargs else reevaluate()
        if not response:
            self.last_response = self.output_response("Entity reevaluated", "success")
        else:
            self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_reevaluate_record(self, **kwargs: Any) -> None:
        """
        Reevaluate a record and optionally return information

        Syntax:
            reevaluate_record data_source_code record_id [-f FLAG ...]

        Examples:
            reevaluate_record customers 1001
            reevaluate_record customers 1001 -f SZ_WITH_INFO

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        reevaluate = functools.partial(
            self.sz_engine.reevaluate_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = reevaluate(kwargs["flags"]) if "flags" in kwargs else reevaluate()
        if not response:
            self.last_response = self.output_response("Record reevaluated", "success")
        else:
            self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_search_by_attributes(self, **kwargs: Any) -> None:
        """
        Search for entities

        Syntax:
            search_by_attributes attributes [search_profile] [-f FLAG ...]

        Examples:
            search_by_attributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}'
            search_by_attributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}' -f SZ_SEARCH_BY_ATTRIBUTES_MINIMAL_ALL

        Arguments:
            attributes = Senzing mapped JSON containing the attributes to search on
            search_profile = A configured search profile (don't specify for default)
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        if "flags" in kwargs:
            response = self.sz_engine.search_by_attributes(
                kwargs["parsed_args"].attributes,
                kwargs["flags"],
                kwargs["parsed_args"].search_profile,
            )
        else:
            response = self.sz_engine.search_by_attributes(
                kwargs["parsed_args"].attributes,
                search_profile=kwargs["parsed_args"].search_profile,
            )

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_why_entities(self, **kwargs: Any) -> None:
        """
        Determine how entities relate to each other

        Syntax:
            why_entities entity_id_1 entity_id_2 [-f flag ...]

        Examples:
            why_entities 96 200011
            why_entities 96 200011 -f SZ_WHY_ENTITIES_DEFAULT_FLAGS SZ_INCLUDE_MATCH_KEY_DETAILS

        Arguments:
            entity_id_1 = Identifier for first entity
            entity_id_2 = Identifier for second entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        why_entities = functools.partial(
            self.sz_engine.why_entities,
            kwargs["parsed_args"].entity_id_1,
            kwargs["parsed_args"].entity_id_2,
        )

        response = why_entities(kwargs["flags"]) if "flags" in kwargs else why_entities()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_why_record_in_entity(self, **kwargs: Any) -> None:
        """
        Determine why a particular record resolved to an entity

        Syntax:
            why_record_in_entity data_source_code record_id [-f FLAG ...]

        Examples:
            why_record_in_entity reference 2121
            why_record_in_entity reference 2121 -f SZ_WHY_RECORD_IN_ENTITY_DEFAULT_FLAGS SZ_INCLUDE_MATCH_KEY_DETAILS

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        why_record = functools.partial(
            self.sz_engine.why_record_in_entity,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = why_record(kwargs["flags"]) if "flags" in kwargs else why_record()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_why_records(self, **kwargs: Any) -> None:
        """
        Determine how two records relate to each other

        Syntax:
            why_records data_source_code_1 record_id_1 data_source_code_2 record_id_2 [-f flag ...]

        Examples:
            why_records reference 2121 watchlist 2092
            why_records reference 2121 watchlist 2092 -f SZ_WHY_RECORDS_DEFAULT_FLAGS SZ_INCLUDE_MATCH_KEY_DETAILS

        Arguments:
            data_source_code_1 = Data source code for first record
            record_id_1 = Identifier for first record
            data_source_code_2 = Data source code for second record
            record_id_2 = Identifier for second record
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        why_records = functools.partial(
            self.sz_engine.why_records,
            kwargs["parsed_args"].data_source_code_1,
            kwargs["parsed_args"].record_id_1,
            kwargs["parsed_args"].data_source_code_2,
            kwargs["parsed_args"].record_id_2,
        )

        response = why_records(kwargs["flags"]) if "flags" in kwargs else why_records()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_why_search(self, **kwargs: Any) -> None:
        """
        Determine why search attributes relate to an existing entity

        Syntax:
            why_search attributes entity_id [-f FLAG ...]

        Examples:
            why_search '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}' 1
            why_search '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}' 1 -f SZ_WHY_SEARCH_DEFAULT_FLAGS SZ_INCLUDE_MATCH_KEY_DETAILS

        Arguments:
            attributes = Senzing mapped JSON containing the attributes to search on
            entity_id = Identifier for an entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://senzing.com/v4-sdk-flags/"""

        if "flags" in kwargs:
            response = self.sz_engine.why_search(
                kwargs["parsed_args"].attributes,
                kwargs["parsed_args"].entity_id,
                kwargs["flags"],
                kwargs["parsed_args"].search_profile,
            )
        else:
            response = self.sz_engine.why_search(
                kwargs["parsed_args"].attributes,
                kwargs["parsed_args"].entity_id,
                search_profile=kwargs["parsed_args"].search_profile,
            )

        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # szproduct commands
    # -----------------------------------------------------------------------------

    @do_methods_decorator
    def do_get_license(self) -> None:
        """
        Get license information

        Syntax:
            get_license"""

        response = self.sz_product.get_license()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_version(self) -> None:  # pylint: disable=invalid-name
        """
        Get version information

        Syntax:
            get_version"""

        response = self.sz_product.get_version()
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # Custom commands
    # -----------------------------------------------------------------------------

    def do_hidden(self, line: str) -> None:  # pylint: disable=unused-argument
        print()
        print("\n\n".join(map(str, self.__hidden_cmds)))
        print()

    def do_history(self, line: str) -> None:  # pylint: disable=unused-argument
        """
        Displays the command history

        Syntax:
            history
        """
        do_history()

    def do_response_to_clipboard(self, line: str) -> None:  # pylint: disable=[unused-argument]
        """
        Copy the last command response to the clipboard

        Syntax:
            response_to_clipboard
        """
        response_to_clipboard(self.last_response)

    @do_methods_decorator
    def do_response_to_file(self, **kwargs: Any) -> None:
        """
        Copy the last command response to a file

        Syntax:
            response_to_file output_file [-a] [-c]

        Examples:
            response_to_file /tmp/response.out
            response_to_file /tmp/response.out -a


        Arguments:
            output_file = File to save response to
            -a = Append to file
            -c = Add command and response to file
        """
        response_to_file(
            kwargs["parsed_args"].file_path,
            kwargs["parsed_args"].append_to_file,
            kwargs["parsed_args"].add_command,
            self.last_command,
            self.last_response,
        )

    def do_response_reformat_json(self, line: str) -> None:  # pylint: disable=[unused-argument]
        """
        Convert the last response between json and jsonl formatting

        Syntax:
            response_reformat_json
        """

        self.last_response = response_reformat_json(self.last_response, self.per_cmd_config["color_output"])  # type: ignore[arg-type]

    def help_set(self):

        # Some settings can have additional information, such as the history file name
        # Get a list of any settings that have an extra 'value'
        config_values = [element.get("value", "") for element in CONFIG_SETTINGS.values()]

        print(
            textwrap.dedent(
                f"""\

        {colorize_str('Syntax:', 'highlight2')}
            set {colorize_str('setting value', "dim")}

        {colorize_str('Settings:', 'highlight2')} """
            )
        )
        print(
            colorize_str(
                f"    {'Setting':<17} {'Possible values':<34} {'Current':<10} {'Description':<51} {'Value' if any(config_values) else ''}",
                "dim",
            )
        )
        print()

        for idx, (setting, values_description) in enumerate(CONFIG_SETTINGS.items()):
            values = ", ".join(values_description["values"])
            current_value = self.config[setting]
            if current_value is True:
                current_value = "on"  # type: ignore[assignment]

            if current_value is False:
                current_value = "off"  # type: ignore[assignment]
            current_value = colorize_str(current_value, "bold")

            desc = colorize_str(values_description["description"], "dim")
            print(
                f"    {setting:<17} {'[' + values + ']':<34} {current_value:<19} {desc:<61} {config_values[idx] if config_values[idx] else ''}"
            )
        print()

    def do_set(self, line: str):
        """Type 'set' to see help"""
        if not line:
            self.help_set()
            return

        line_list = line.split()
        if len(line_list) < 1:
            self.help_set()
            return

        setting = line_list[0].lower()
        if len(line_list) >= 2:
            value = line_list[1].lower()

        if setting not in CONFIG_SETTINGS:
            print_error(f"{setting} is an unknown configuration setting, type 'set' to see settings")
            return

        if "value" in locals() and value not in CONFIG_SETTINGS[setting]["values"]:
            print_error(f"{value} is not a valid value for configuration setting {setting}, type 'set' to see values ")
            return

        # Convert set values to configuration bools
        if "value" in locals() and value == "on":
            value = True  # type: ignore[assignment]

        if "value" in locals() and value == "off":
            value = False  # type: ignore[assignment]

        # If a value wasn't received and the configuration setting is a bool, reverse current value
        if "value" not in locals():
            if isinstance(self.config[setting], bool):
                value = not self.config[setting]  # type: ignore[assignment]
            else:
                self.help_set()
                return

        # Update config dictionary and write new settings to config file
        self.config[setting] = value
        self.write_config()

        # Update theme and command prompt if theme is changed
        if setting in ("theme", "color_output"):
            self.prompt = colorize_cmd_prompt(self.prompt_str, self.prompt_color, self.config["color_output"])  # type: ignore[arg-type]
            if setting == "theme":
                Colors.set_theme(value)

        # Reinitialize the Cmd module object and Senzing objects if engine logging is requested, checked in postcmd
        if setting == "debug_sz_engine":
            self.debug_reinit["reinitialize"] = True
            self.debug_reinit["debug_trace"] = bool(value)

        # Enable or disable use of history file
        if setting == "history_file":
            if not self.history_file_error:
                if self.history_file:
                    if not value or value == "off":
                        print_warning(
                            "History file has been erased and won't be used unless re-enabled with the set command"
                        )
                        history_disabled(self.history_file)
                        self.history_file = None
                        CONFIG_SETTINGS["history_file"]["value"] = None
                if value or value == "on":
                    self.enable_history()
            else:
                print_warning("History file isn't available in this session due to a previous error")
                return

        if isinstance(self.config[setting], bool):
            print_response(f"{setting} is now {'enabled' if value or value == 'on' else 'disabled'}", color="success")
        else:
            print_response(f"{setting} set to {value}", color="success")

    # -----------------------------------------------------------------------------
    # Helper methods
    # -----------------------------------------------------------------------------

    def set_pre_cmd_settings(self, input_line: str) -> None:
        """Before running each command check if there are per cmd settings such as json, jsonl, timer, etc
        If there are, modify the per_cmd_config dictionary to those values just for the run of the command"""
        cmd_line_settings = self.get_per_cmd_settings(input_line)
        self.per_cmd_config = self.config.copy()
        if cmd_line_settings:
            for cmd_setting in cmd_line_settings:
                config_key = SETTINGS_TO_CONFIG_MAP[cmd_setting][0]
                config_setting = SETTINGS_TO_CONFIG_MAP[cmd_setting][1]
                # Per command settings are always bools
                if isinstance(config_setting, bool):
                    self.per_cmd_config[config_key] = config_setting  # type: ignore

    def get_per_cmd_settings(self, cmd_line: str) -> List[str]:
        """Get the settings from a command"""
        return [s for s in cmd_line.split() if s.lower() in PER_CMD_SETTINGS]

    def remove_per_cmd_settings(self, cmd_line: str) -> str:
        """Remove any settings from a command"""
        cmd_list_clean = [c for c in self.parse(cmd_line) if c.lower() not in PER_CMD_SETTINGS]
        return shlex.join(cmd_list_clean)

    def parse(self, argument_string: str) -> List[str]:
        """Parses command arguments into a list of argument strings"""
        try:
            return shlex.split(argument_string)
        except ValueError as err:
            print_error(f"Unable to parse arguments: {err}")
            raise

    def read_config(self) -> None:
        try:
            with open(self.config_file, "r", encoding="utf-8") as config_read:
                self.config.update(json.load(config_read))
        except (OSError, json.JSONDecodeError) as err:
            print_warning(f"Error reading configuration from {self.config_file}: {err}")

    def write_config(self) -> None:
        if self.docker_launched:
            return

        try:
            with open(self.config_file, "w", encoding="utf-8") as config_write:
                config_write.write(json.dumps(self.config, indent=2))
        except (OSError, json.JSONDecodeError) as err:
            if not self.config_error:
                print_warning(f"Error writing configuration to {self.config_file}: {err}")
                self.config_error = not self.config_error

    def enable_history(self):
        """Attempt to create or use a history file for an interactive session"""
        self.history_file = history_setup(MODULE_NAME)
        if self.history_file:
            CONFIG_SETTINGS["history_file"]["value"] = self.history_file
        else:
            self.history_file_error = True

    # -------------------------------------------------------------------------
    # Auto completers
    # -------------------------------------------------------------------------

    # pylint: disable=[unused-argument]

    # @staticmethod
    def cmd_settings_decorator(func):
        @functools.wraps(func)
        def wrapper_decorator(self, *args, **kwargs):
            comps = []
            func_name = func.__name__.lstrip("complete_")
            line = args[1]
            line_parse = shlex.split(line)
            num_args = 0
            num_args_required = 0
            text = args[0]

            # # Not all do_ commands have arguments, e.g., get_license(), collect command arguments if it has any
            if self.subparsers.choices.get(func_name):
                for action in self.subparsers.choices[func_name]._actions:  # pylint: disable=protected-access
                    if isinstance(action, argparse._StoreAction):  # pylint: disable=protected-access
                        num_args += 1
                        if action.required:
                            num_args_required += 1

            # Check if have the required number of arguments specified and there is a space or the last element
            # in line_parse fully or partially matches command settings in PER_CMD_SETTINGS
            # The check on -f is to prevent command settings being suggested when autocompleting flags
            if (
                len(line_parse) - 1 >= num_args_required
                and (
                    line[-1:] == " "
                    or any(line_parse[-1].startswith(c[: len(line_parse[-1])]) for c in PER_CMD_SETTINGS)
                )
                and line_parse[-1] != "-f"
            ):
                comps = [s for s in PER_CMD_SETTINGS if s.lower().startswith(text.lower()) and s not in line_parse]

            # Set kwargs to be available in the wrapper function
            kwargs["cmd_settings"] = comps
            return func(self, *args, **kwargs)

        return wrapper_decorator

    # Auto complete engine flags from self.szengineflags
    def flags_completes(self, text: str, line: str) -> List[str]:
        flags = []
        if re.match(".* -f +", line):
            flags = [flag for flag in self.engine_flags_list if flag.lower().startswith(text.lower())]
        return flags

    # Auto complete engine flags and JSON key/value syntax
    def json_and_flags_completes(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        # Do not change the order of these matches!

        # comp_cmd = re.match(r"\w+ +", line)
        comp_cmd = re.match(r"\w+ +\w+ +\w+ +", line)
        if comp_cmd and len(comp_cmd.group()) == len(line):
            return ["""'{"": "", """]

        re_flags = re.search(" -f +.*$", line)
        if re_flags and re_flags.end() == endidx:
            flags = [flag for flag in self.engine_flags_list if flag.lower().startswith(text.lower())]
            return flags

        # re_j_start = re.search("'{{1}", line)
        re_j_start = re.match(r"\w+ +\w+ +\w+ +'{{1}", line)
        if re_j_start:

            # Look ahead a couple of characters...
            attr_check = line[begidx : begidx + 2]

            if re.search("'{", line[begidx:]):
                return []

            if attr_check == '":' or re.match(r"\w", attr_check):
                attrs = [attr for attr in self.attrs if attr.lower().startswith(text.lower())]
                return attrs

            if not text and line[begidx - 1 :] == '"':
                return ["}' "]

        return []

    @staticmethod
    def path_completes(
        text: str,
        line: str,
        begidx: int,
        endidx: int,
        calling_cmd: str,
    ) -> List[str]:
        """Auto complete paths for commands"""

        completes = []
        path_comp = line[len(calling_cmd) + 1 : endidx]
        fixed = line[len(calling_cmd) + 1 : begidx]
        for path in glob.glob(f"{path_comp}*"):
            path = path + os.sep if path and os.path.isdir(path) and path[-1] != os.sep else path
            completes.append(path.replace(fixed, "", 1))

        return completes

    @cmd_settings_decorator
    def complete_add_record(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_check_repository_performance(
        self, text: str, line: str, begidx: int, endidx: int, **kwargs
    ) -> List[str]:
        return kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_delete_record(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    def complete_export_csv_entity_report(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("export_csv_entity_report +", line) and not re.match("export_csv_entity_report +.* +", line):
            return self.path_completes(text, line, begidx, endidx, "export_csv_entity_report")

        if re.match(".* -f +", line):
            return self.flags_completes(text, line)
        return []

    def complete_export_json_entity_report(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("export_json_entity_report +", line) and not re.match("export_json_entity_report +.* +", line):
            return self.path_completes(text, line, begidx, endidx, "export_json_entity_report")

        if re.match(".* -f +", line):
            return self.flags_completes(text, line)
        return []

    @cmd_settings_decorator
    def complete_find_interesting_entities_by_entity_id(
        self, text: str, line: str, begidx: int, endidx: int, **kwargs
    ) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_find_interesting_entities_by_record_id(
        self, text: str, line: str, begidx: int, endidx: int, **kwargs
    ) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_find_network_by_entity_id(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_find_network_by_record_id(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_find_path_by_entity_id(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_find_path_by_record_id(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_config(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_config_registry(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_repository_info(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_entity_by_entity_id(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_entity_by_record_id(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_license(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_record(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_stats(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_template_config(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_version(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_virtual_entity_by_record_id(
        self, text: str, line: str, begidx: int, endidx: int, **kwargs
    ) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_how_entity_by_entity_id(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_get_record_preview(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_process_redo_record(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_reevaluate_entity(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_reevaluate_record(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_search_by_attributes(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]
        # return self.json_and_flags_completes(text, line, begidx, endidx)

    @cmd_settings_decorator
    def complete_why_entities(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_why_record_in_entity(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_why_records(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    @cmd_settings_decorator
    def complete_why_search(self, text: str, line: str, begidx: int, endidx: int, **kwargs) -> List[str]:
        return self.flags_completes(text, line) + kwargs["cmd_settings"]

    def complete_response_to_file(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("response_to_file +", line):
            return self.path_completes(text, line, begidx, endidx, "response_to_file")
        return []

    def complete_set(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if m := re.match("set (.*) ", line):
            return [value for value in CONFIG_SETTINGS[m.group(1)]["values"] if value.startswith(text.lower())]
        if re.match("set +", line):
            return [setting for setting in CONFIG_SETTINGS if setting.startswith(text.lower())]
        return []

    # pylint: enable=[unused-argument]


def parse_cli_args() -> argparse.Namespace:
    """Parse the CLI arguments"""
    arg_parser = argparse.ArgumentParser(
        allow_abbrev=False,
        description="Utility to interact with Senzing APIs",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    arg_parser.add_argument(
        "-c",
        "--ini-file",
        help="optional path and file name of sz_engine_config.ini to use",
    )
    non_interactive_group = arg_parser.add_mutually_exclusive_group()
    non_interactive_group.add_argument(
        "-C",
        "--command",
        action="append",
        nargs="+",
        help="run command(s) without starting an interactive session",
    )
    non_interactive_group.add_argument(
        "-f",
        "--file-to-process",
        default=None,
        help="path and file name of file with commands to run",
        nargs="?",
    )

    return arg_parser.parse_args()


def main() -> None:
    """main"""

    cli_args = parse_cli_args()

    # Check an engine configuration can be located
    engine_config = get_engine_config(cli_args.ini_file)

    # Dictionary passed to SzCmdShell for determining if a reinitialization is expected or exit
    debug_reinitialize = {"verbose_logging": False, "reinitialize": False, "prior_instance_reinitialized": False}

    # Execute SzCmdShell and catch ctrl-c
    try:
        # Execute command(s) non-interactively from the command line
        if cli_args.command:
            cmd_obj = SzCmdShell(engine_config, debug_reinitialize)
            cmd_obj.commands_from_cli(cli_args.command)
            return

        # Execute a file of commands
        if cli_args.file_to_process:
            cmd_obj = SzCmdShell(engine_config, debug_reinitialize)
            cmd_obj.commands_from_file(cli_args.file_to_process)
            return

        # Interactive session
        while 1:
            cmd_obj = SzCmdShell(engine_config, debug_reinitialize)
            cmd_obj.cmdloop()
            # Reinitialize or exit? Set to true when engine verbose logging is turned on
            if not debug_reinitialize["reinitialize"]:
                break

            debug_reinitialize["reinitialize"] = False
            debug_reinitialize["prior_instance_reinitialized"] = True

            del cmd_obj
    except KeyboardInterrupt:
        return


if __name__ == "__main__":
    main()
