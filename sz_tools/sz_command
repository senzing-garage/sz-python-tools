#! /usr/bin/env python3

""" # TODO """

# TODO - Ant - Settings, even if can't write always have a default set each session that can be set
# TODO - Ant - Response to file with append should also add the prior command or arg to add commands to both file an clipboard?
# TODO - Ant - Once moved to settings (probably needs to be dict now) Each pre command makes a copy of settings to change for each per command setting to temporarily use

import argparse
import cmd
import configparser
import functools
import glob
import json
import os
import pathlib
import re
import shlex
import sys
import textwrap
import time
from typing import Any, Callable, List, TypeVar, Union, cast

from _tool_helpers import (
    Colors,
    colorize_cmd_prompt,
    colorize_output,
    colorize_str,
    do_help,
    do_history,
    do_shell,
    get_engine_config,
    get_engine_flag_names,
    get_engine_flags_as_int,
    history_setup,
    print_debug,
    print_error,
    print_info,
    print_response,
    print_warning,
    response_reformat_json,
    response_to_clipboard,
    response_to_file,
)
from senzing import SzAbstractFactory, SzError

_WrappedFunc = TypeVar("_WrappedFunc", bound=Callable[..., Any])


MODULE_NAME = pathlib.Path(__file__).stem

# TODO - Ant - Add debug and timer?
# Per command JSON formatting options
PER_CMD_FORMATTERS = [
    "json",
    "jsonl",
    "color",
    "colour",
    "nocolor",
    "nocolour",
]

# TODO - Ant - Some of these will go away with new set command
CMDS_NOT_TO_SET_LAST_COMMAND = [
    "history",
    "json_color",
    "json_format",
    "response_reformat_json",
    "response_to_clipboard",
    "response_to_file",
    "scroll_output",
    "timer",
]


# -------------------------------------------------------------------------
# Metadata
# -------------------------------------------------------------------------

__all__ = ["SzCmdShell"]
__version__ = "0.0.1"  # See https://www.python.org/dev/peps/pep-0396/
__date__ = "2024-06-13"
__updated__ = "2024-06-13"

# Due to the way the Cmd module works, don't want doc strings on everything
# pylint: disable=missing-function-docstring


# -------------------------------------------------------------------------
# Decorators
# -------------------------------------------------------------------------


def do_methods_decorator(do_method: _WrappedFunc) -> _WrappedFunc:
    @functools.wraps(do_method)
    def wrapper(self, *args, **kwargs) -> Any:
        # Remove do_ from wrapped method
        sdk_method_name = do_method.__name__[3:]

        # TODO - Ant - Change name for new settings like timer, debug
        # Apply and remove any command formatters such as jsonl, nocolor, etc
        cmd_args = self.apply_formats(args[0])

        if self.debug_sdk_call:
            sdk_call = sdk_method_name
            sdk_call_dict = {}

        # If there is a parser for the method it takes arguments
        if sdk_method_name in self.subparsers.choices:
            try:
                # Parse arguments for a command and add to kwargs to use in calling do_ method
                # Returns an argparse.Namespace, make a dict for logic checking and less complaints from mypy!
                kwargs["parsed_args"] = self.parser.parse_args([f"{sdk_method_name}"] + self.parse(cmd_args))
                # Get the argparse.Namespace as a dictionary to change any modified arguments for debug
                if self.debug_sdk_call:
                    sdk_call_dict = kwargs["parsed_args"].__dict__.copy()

                # If the command has flags get the int value
                if hasattr(kwargs["parsed_args"], "flags") and kwargs["parsed_args"].flags:
                    kwargs["flags"] = get_engine_flags_as_int(kwargs["parsed_args"].flags)
                    if self.debug_sdk_call:
                        sdk_call_dict["flags"] = kwargs["flags"]

                # If the command uses *record_keys build the expected list of tuples for the SDK
                if hasattr(kwargs["parsed_args"], "record_keys") or hasattr(kwargs["parsed_args"], "avoid_record_keys"):
                    rk_type = "record_keys" if "record_keys" in kwargs["parsed_args"] else "avoid_record_keys"
                    record_keys = getattr(kwargs["parsed_args"], rk_type)
                    # 1 list element == str from quotes: get_virtual_entity_by_record_id 'REFERENCE 2012 customers 1001'
                    # >1 list elements == list such as: find_path_by_record_id ...-a customers 1001 reference 2001
                    # Split single str list element into multiple elements
                    if len(record_keys) == 1:
                        record_keys = record_keys[0].split()

                    # TODO - Ant - Move to SDK helpers?
                    if len(record_keys) % 2 != 0:
                        print_error(f"Uneven number of data source codes and record IDs: {record_keys}")
                        return None

                    # Build the list of tuples for the SDK
                    # [('REFERENCE', '2012'), ('CUSTOMERS', '1001')]
                    kwargs[locals()["rk_type"]] = [tuple(record_keys[i : i + 2]) for i in range(0, len(record_keys), 2)]

                    if self.debug_sdk_call:
                        sdk_call_dict[locals()["rk_type"]] = kwargs[locals()["rk_type"]]

                # If the method uses entity_ids build the list for the SDK
                # avoid_entity_ids doesn't need to be checked, it is parsed as a list
                if hasattr(kwargs["parsed_args"], "entity_ids"):
                    entity_ids = kwargs["parsed_args"].entity_ids
                    if len(entity_ids) == 1:
                        entity_ids = entity_ids[0].replace(",", " ")
                        entity_ids = entity_ids.split()

                    try:
                        kwargs["entity_ids"] = [int(i) for i in entity_ids]
                    except ValueError:
                        non_ints = [id for id in entity_ids if not id.isdigit()]
                        print_error(f"Entity IDs should be integers: {', '.join(non_ints)}")
                        return None

                    if self.debug_sdk_call:
                        sdk_call_dict["entity_ids"] = kwargs["entity_ids"]

            # Catch argument errors from parser.parse_args and display the commands help
            # Argparse parser error method is subclassed by SzCommandArgumentParser and displays the error
            except SystemExit:
                self.do_help(do_method.__name__)
                return None
            # Catch parsing errors such as missing single quote around JSON, the error is displayed by parse()
            except ValueError:
                return None
            # Catch errors from methods such as get_engine_flags
            except (KeyError, SzError) as err:
                print_error(err)
                return None

        if self.timer:
            timer_start = time.perf_counter()

        # Run the decorated method passing back kwargs for use in SDK call
        try:
            if self.debug_sdk_call:
                sdk_call_args = ", ".join([f"{k} = {v}" for k, v in sdk_call_dict.items() if v])
                sdk_call = f"{sdk_method_name}({sdk_call_args})"
                print_debug(sdk_call)
            result = do_method(self, **kwargs)
        except (SzError, IOError, ValueError) as err:
            result = None
            print_error(err)
        finally:
            if self.timer:
                exec_time = time.perf_counter() - timer_start
                print_info(
                    f"Approximate execution time (s): {exec_time:.5f}",
                )

        return result

    return cast(_WrappedFunc, wrapper)


# -------------------------------------------------------------------------
# Classes
# -------------------------------------------------------------------------
class SzCommandArgumentParser(argparse.ArgumentParser):
    """Subclass ArgumentParser, override error() with custom message"""

    def error(self, message: str) -> None:
        self.exit(
            2,
            print_error(message),
        )


class SzCmdShell(cmd.Cmd):
    """Main Cmd class"""

    def __init__(
        self,
        engine_settings: str,
        cli_args: argparse.Namespace,
    ):
        super().__init__()

        self.cli_args = cli_args
        self.engine_settings = engine_settings

        # Acquire Senzing engines
        try:
            self.sz_factory = SzAbstractFactory(
                MODULE_NAME, self.engine_settings, verbose_logging=self.cli_args.debug_trace
            )
            self.sz_config = self.sz_factory.create_config()
            self.sz_configmgr = self.sz_factory.create_configmanager()
            self.sz_diagnostic = self.sz_factory.create_diagnostic()
            self.sz_engine = self.sz_factory.create_engine()
            self.sz_product = self.sz_factory.create_product()
        except SzError as err:
            print_error(err)
            sys.exit(1)

        # Get Senzing engine flag names for use in auto completion
        self.engine_flags_list = get_engine_flag_names()

        # If default config ID changes reinitialize
        self.reinitialize = False

        # Collect attributes from configuration
        self.attrs = self.get_config_attr_codes()

        # Could be deprecated, undocumented, not supported, experimental or not relevant
        self.__hidden_cmds = (
            "do_EOF",
            "do_find_interesting_entities_by_entity_id",
            "do_find_interesting_entities_by_record_id",
            "do_get_redo_record",
            "do_get_feature",
            "do_help",
            "do_hidden",
            "do_shell",
        )

        # Session wide color disabled?
        self.color_disabled = self.cli_args.color_disable

        # Themes - set early, used for setting cmd prompt, use the default colors set by the terminal
        self.themes = Colors.AVAILABLE_THEMES
        self.theme = "TERMINAL"
        Colors.set_theme(self.theme)

        # Cmd module settings
        self.intro = ""
        self.prompt = colorize_cmd_prompt("szcmd", "info", self.color_disabled)
        # self.prompt = colorize_cmd_prompt("szcmd", "info", True)

        # Readline and history
        self.history_avail = False
        self.history_disable = self.cli_args.hist_disable
        self.history_msg = ""

        # For pretty printing JSON responses
        self.cmd_color = False
        self.cmd_format = False
        self.color_json = True
        self.color_json_cmd = False
        self.format_json = False
        self.format_json_cmd = False

        # General
        self.last_response = ""
        self.last_command = ""
        self.scroll_output = False
        # TODO - Ant -
        self.debug_sdk_call = False
        self.timer = False

        # Configuration ini file for this tool
        config_file_str = f"~/.{MODULE_NAME}{'.ini'}"
        self.config_file = pathlib.Path(config_file_str).expanduser()
        self.config_file_exists = pathlib.Path(self.config_file).exists()

        # Display can't read/write config message once, not at all in container
        self.config_error = False
        docker_launched = os.getenv("SENZING_DOCKER_LAUNCHED")
        self.docker_launched = True if docker_launched in ("y", "yes", "t", "true", "on", "1") else False

        # -------------------------------------------------------------------------
        # do_* method parsers
        # -------------------------------------------------------------------------

        self.parser = SzCommandArgumentParser(
            add_help=False,
            prog=MODULE_NAME,
            usage=argparse.SUPPRESS,
        )
        self.subparsers = self.parser.add_subparsers()

        # szconfig parsers

        get_config_parser = self.subparsers.add_parser("get_config", usage=argparse.SUPPRESS)
        get_config_parser.add_argument("config_id", type=int)

        # szconfigmanager parsers

        replace_default_config_id_parser = self.subparsers.add_parser(
            "replace_default_config_id", usage=argparse.SUPPRESS
        )
        replace_default_config_id_parser.add_argument("current_default_config_id", type=int)
        replace_default_config_id_parser.add_argument("new_default_config_id", type=int)

        set_default_config_id_parser = self.subparsers.add_parser("set_default_config_id", usage=argparse.SUPPRESS)
        set_default_config_id_parser.add_argument("config_id", type=int)

        # szdiagnostic parsers

        check_datastore_performance_parser = self.subparsers.add_parser(
            "check_datastore_performance", usage=argparse.SUPPRESS
        )
        check_datastore_performance_parser.add_argument("seconds_to_run", default=3, nargs="?", type=int)

        get_feature_parser = self.subparsers.add_parser("get_feature", usage=argparse.SUPPRESS)
        get_feature_parser.add_argument("featureID", type=int)

        purge_repository_parser = self.subparsers.add_parser("purge_repository", usage=argparse.SUPPRESS)
        purge_repository_parser.add_argument(
            "-FORCEPURGE",
            "--FORCEPURGE",
            action="store_true",
            default=False,
            dest="force_purge",
            required=False,
        )

        # szengine parsers

        add_record_parser = self.subparsers.add_parser("add_record", usage=argparse.SUPPRESS)
        add_record_parser.add_argument("data_source_code")
        add_record_parser.add_argument("record_id")
        add_record_parser.add_argument("record_definition")
        add_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        delete_record_parser = self.subparsers.add_parser("delete_record", usage=argparse.SUPPRESS)
        delete_record_parser.add_argument("data_source_code")
        delete_record_parser.add_argument("record_id")
        delete_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        export_csv_entity_report_parser = self.subparsers.add_parser(
            "export_csv_entity_report", usage=argparse.SUPPRESS
        )
        export_csv_entity_report_parser.add_argument("output_file")
        export_csv_entity_report_parser.add_argument("-f", "--flags", nargs="+", required=False)
        export_csv_entity_report_parser.add_argument("-t", "--csv_column_list", required=False, type=str)

        export_json_entity_report_parser = self.subparsers.add_parser(
            "export_json_entity_report", usage=argparse.SUPPRESS
        )
        export_json_entity_report_parser.add_argument("output_file")
        export_json_entity_report_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_interesting_entities_by_entity_id_parser = self.subparsers.add_parser(
            "find_interesting_entities_by_entity_id", usage=argparse.SUPPRESS
        )
        find_interesting_entities_by_entity_id_parser.add_argument("entity_id", type=int)
        find_interesting_entities_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_interesting_entities_by_record_id_parser = self.subparsers.add_parser(
            "find_interesting_entities_by_record_id", usage=argparse.SUPPRESS
        )
        find_interesting_entities_by_record_id_parser.add_argument("data_source_code")
        find_interesting_entities_by_record_id_parser.add_argument("record_id")
        find_interesting_entities_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_network_by_entity_id_parser = self.subparsers.add_parser(
            "find_network_by_entity_id", usage=argparse.SUPPRESS
        )
        find_network_by_entity_id_parser.add_argument("entity_ids", nargs="+")
        find_network_by_entity_id_parser.add_argument("max_degrees", type=int)
        find_network_by_entity_id_parser.add_argument("build_out_degrees", type=int)
        find_network_by_entity_id_parser.add_argument("build_out_max_entities", type=int)
        find_network_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_network_by_record_id_parser = self.subparsers.add_parser(
            "find_network_by_record_id", usage=argparse.SUPPRESS
        )
        find_network_by_record_id_parser.add_argument("record_keys", nargs="+")
        find_network_by_record_id_parser.add_argument("max_degrees", type=int)
        find_network_by_record_id_parser.add_argument("build_out_degrees", type=int)
        find_network_by_record_id_parser.add_argument("build_out_max_entities", type=int)
        find_network_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_path_by_entity_id_parser = self.subparsers.add_parser("find_path_by_entity_id", usage=argparse.SUPPRESS)
        find_path_by_entity_id_parser.add_argument("start_entity_id", type=int)
        find_path_by_entity_id_parser.add_argument("end_entity_id", type=int)
        find_path_by_entity_id_parser.add_argument("max_degrees", type=int)
        # find_path_by_entity_id_parser.add_argument("-a", "--avoid_entity_ids", default="", nargs="?", required=False)
        find_path_by_entity_id_parser.add_argument(
            "-a", "--avoid_entity_ids", default=[], nargs="+", required=False, type=int
        )
        find_path_by_entity_id_parser.add_argument(
            # "-r", "--required_data_sources", default="", nargs="?", required=False
            "-r",
            "--required_data_sources",
            default=[],
            nargs="+",
            required=False,
        )
        find_path_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        find_path_by_record_id_parser = self.subparsers.add_parser("find_path_by_record_id", usage=argparse.SUPPRESS)
        find_path_by_record_id_parser.add_argument("start_data_source_code")
        find_path_by_record_id_parser.add_argument("start_record_id")
        find_path_by_record_id_parser.add_argument("end_data_source_code")
        find_path_by_record_id_parser.add_argument("end_record_id")
        find_path_by_record_id_parser.add_argument("max_degrees", type=int)
        find_path_by_record_id_parser.add_argument("-a", "--avoid_record_keys", default=[], nargs="+", required=False)
        find_path_by_record_id_parser.add_argument(
            "-r", "--required_data_sources", default=[], nargs="+", required=False
        )
        find_path_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_entity_by_entity_id_parser = self.subparsers.add_parser("get_entity_by_entity_id", usage=argparse.SUPPRESS)
        get_entity_by_entity_id_parser.add_argument("entity_id", type=int)
        get_entity_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_entity_by_record_id_parser = self.subparsers.add_parser("get_entity_by_record_id", usage=argparse.SUPPRESS)
        get_entity_by_record_id_parser.add_argument("data_source_code")
        get_entity_by_record_id_parser.add_argument("record_id")
        get_entity_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_record_parser = self.subparsers.add_parser("get_record", usage=argparse.SUPPRESS)
        get_record_parser.add_argument("data_source_code")
        get_record_parser.add_argument("record_id")
        get_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        get_virtual_entity_by_record_id_parser = self.subparsers.add_parser(
            "get_virtual_entity_by_record_id", usage=argparse.SUPPRESS
        )
        get_virtual_entity_by_record_id_parser.add_argument("record_keys", nargs="+")
        get_virtual_entity_by_record_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        how_entity_by_entity_id_parser = self.subparsers.add_parser("how_entity_by_entity_id", usage=argparse.SUPPRESS)
        how_entity_by_entity_id_parser.add_argument("entity_id", type=int)
        how_entity_by_entity_id_parser.add_argument("-f", "--flags", nargs="+", required=False)

        preprocess_record_parser = self.subparsers.add_parser("preprocess_record", usage=argparse.SUPPRESS)
        preprocess_record_parser.add_argument("record_definition")
        preprocess_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        process_redo_record_parser = self.subparsers.add_parser("process_redo_record", usage=argparse.SUPPRESS)
        process_redo_record_parser.add_argument("redo_record")
        process_redo_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        reevaluate_entity_parser = self.subparsers.add_parser("reevaluate_entity", usage=argparse.SUPPRESS)
        reevaluate_entity_parser.add_argument("entity_id", type=int)
        reevaluate_entity_parser.add_argument("-f", "--flags", nargs="+", required=False)

        reevaluate_record_parser = self.subparsers.add_parser("reevaluate_record", usage=argparse.SUPPRESS)
        reevaluate_record_parser.add_argument("data_source_code")
        reevaluate_record_parser.add_argument("record_id")
        reevaluate_record_parser.add_argument("-f", "--flags", nargs="+", required=False)

        search_by_attributes_parser = self.subparsers.add_parser("search_by_attributes", usage=argparse.SUPPRESS)
        search_by_attributes_parser.add_argument("attributes")
        search_by_attributes_parser.add_argument("search_profile", default="SEARCH", nargs="?")
        search_by_attributes_parser.add_argument("-f", "--flags", nargs="+", required=False)

        why_entities_parser = self.subparsers.add_parser("why_entities", usage=argparse.SUPPRESS)
        why_entities_parser.add_argument("entity_id_1", type=int)
        why_entities_parser.add_argument("entity_id_2", type=int)
        why_entities_parser.add_argument("-f", "--flags", nargs="+", required=False)

        why_record_in_entity_parser = self.subparsers.add_parser("why_record_in_entity", usage=argparse.SUPPRESS)
        why_record_in_entity_parser.add_argument("data_source_code")
        why_record_in_entity_parser.add_argument("record_id")
        why_record_in_entity_parser.add_argument("-f", "--flags", nargs="+", required=False)

        why_records_parser = self.subparsers.add_parser("why_records", usage=argparse.SUPPRESS)
        why_records_parser.add_argument("data_source_code_1")
        why_records_parser.add_argument("record_id_1")
        why_records_parser.add_argument("data_source_code_2")
        why_records_parser.add_argument("record_id_2")
        why_records_parser.add_argument("-f", "--flags", nargs="+", required=False)

        # Utility parsers

        response_to_file_parser = self.subparsers.add_parser("response_to_file", usage=argparse.SUPPRESS)
        response_to_file_parser.add_argument("file_path")
        # TODO - Ant -
        response_to_file_parser.add_argument(
            "-a", "--append", action="store_true", default=False, dest="append_to_file", required=False
        )
        response_to_file_parser.add_argument(
            "-c", "--command", action="store_true", default=False, dest="add_command", required=False
        )

        set_theme_parser = self.subparsers.add_parser("set_theme", usage=argparse.SUPPRESS)
        set_theme_parser.add_argument(
            "theme",
            choices=self.themes,
            nargs=1,
        )

    def get_config_attr_codes(self) -> List[str]:
        # TODO - Work in progress for JSON autocomplete
        # TODO - Ant - If anything goes wrong, don't care as this is only used for autocomplete, if bigger issues with Sz would
        #              show up before this
        try:
            config_id = self.sz_engine.get_active_config_id()
            config = self.sz_configmgr.get_config(config_id)
            config_json = json.loads(config)
            cfg_attr = config_json["G2_CONFIG"]["CFG_ATTR"]
            attr_codes = [attr["ATTR_CODE"] for attr in cfg_attr if attr["INTERNAL"].lower() == "no"]
        except (SzError, json.JSONDecodeError):
            attr_codes = []

        return attr_codes

    # Call helper function to format and print command responses with constant values
    def output_response(self, response: Union[int, str], color: str = "") -> str:
        formatted_response: str = print_response(
            response,
            self.color_json,
            self.color_json_cmd,
            self.format_json,
            self.format_json_cmd,
            self.cmd_color,
            self.cmd_format,
            self.scroll_output,
            color,
            self.color_disabled,
        )

        return formatted_response

    # -------------------------------------------------------------------------
    # Cmd module methods
    # -------------------------------------------------------------------------

    # Override function from cmd module to make command completion case-insensitive
    def completenames(self, text: str, *ignored: Any) -> List[str]:
        do_text = "do_" + text
        return [a[3:] for a in self.get_names() if a.lower().startswith(do_text.lower())]

    def do_exit(self, _) -> bool:  # type: ignore[no-untyped-def]
        self.do_quit(_)
        return True

    @staticmethod
    def do_quit(_) -> bool:  # type: ignore[no-untyped-def]  # pylint: disable=unused-argument
        return True

    def do_shell(self, line: str) -> None:
        do_shell(self, line)

    # Handle unknown commands
    def default(self, line: str) -> None:
        print_warning("Unknown command, type help or ?")

    # Do nothing if line is empty
    def emptyline(self) -> bool:
        return False

    # Override in cmd module to return methods for autocomplete and help
    # ignoring any hidden commands
    def get_names(self, include_hidden: bool = False) -> List[str]:
        if not include_hidden:
            return [n for n in dir(self.__class__) if n not in self.__hidden_cmds]

        return list(dir(self.__class__))

    def postcmd(self, stop: bool, line: str) -> bool:
        self.format_json_cmd = False
        self.color_json_cmd = False
        self.cmd_color = False
        self.cmd_format = False

        # TODO - Ant -
        if line and line.split()[0] not in CMDS_NOT_TO_SET_LAST_COMMAND:
            self.last_command = self.remove_per_cmd_settings(line)

        # Default configuration ID was changed by set_default_config_id or replace_default_config_id, sz_command
        # doesn't modify the configuration so reinitialize. Update attributes from the new default configuration
        # for auto-completion
        if self.reinitialize:
            print_info("Default configuration ID has changed, reinitializing...")
            try:
                config_id = self.sz_configmgr.get_default_config_id()
                self.sz_factory.reinitialize(config_id)
                self.reinitialize = False
            except SzError as err:
                print_error(err)
                sys.exit(1)

            self.attrs = self.get_config_attr_codes()

        return cmd.Cmd.postcmd(self, stop, line)

    def precmd(self, line: str) -> str:
        return line

    def preloop(self) -> None:
        # TODO - Ant - goes into config too
        if not self.history_disable:
            history_check = history_setup()
            # Non-empty string means error and msg was returned
            if history_check:
                print_warning(history_check)

        # Check if there is a config file and read it, if not create one
        if not self.docker_launched:
            if self.config_file_exists:
                self.read_config()
            else:
                self.write_config()

        print_info(f"Welcome to {MODULE_NAME}. Type help or ? for help", color_disabled=self.color_disabled)

    # -------------------------------------------------------------------------
    # Non-interactive input methods
    # -------------------------------------------------------------------------

    def commands_from_cli(self, commands: List[List[str]]) -> None:
        """
        Run command(s) from the command line, here could be multiple commands and associated arguments in
        commands[]. Command formatters (jsonl, json, etc) are permitted and are handled by sz_cmds_decorator
        """
        number_of_commands = len(commands)
        for each_cmd in commands:
            requested_cmd = each_cmd[0]

            # Build a new list without the requested command resulting in any arguments for the command
            # Due to the way argparse builds the list with the -C argument, also repr() a list item (command argument)
            # if it looks like JSON otherwise the single quotes around the JSON are lost and characters such as space
            # in the JSON string break parsing in the do_* methods
            requested_args = [
                repr(i) if i.strip().startswith("{") and i.strip().endswith("}") else i
                for i in each_cmd
                if i != requested_cmd
            ]

            # Turn the arguments back into a single string for further parsing and call the requested command
            try:
                if number_of_commands > 1:
                    print(f"\n----- {' '.join(each_cmd)} -----")
                cmd_args = " ".join(requested_args)
                self.onecmd(f"{requested_cmd} {cmd_args}")
            except (ValueError, TypeError) as err:
                print_error(f"Problem with command: {err}")

    def commands_from_file(self, file_name: str) -> None:
        """
        Read commands from a file and call the matching commands. Command formatters (jsonl, json, etc) are
        permitted and are handled by sz_cmds_decorator
        """
        try:
            with open(file_name, encoding="utf-8") as cmds_file:
                for each_cmd in cmds_file:
                    each_cmd = each_cmd.strip()

                    # Skip blank lines and comment prefixes
                    if not each_cmd or each_cmd[0:1] in ("#", "-", "/"):
                        continue

                    (requested_cmd, *requested_args) = each_cmd.split()

                    try:
                        cmd_args = " ".join(requested_args)
                        print(f"\n----- {each_cmd} -----")
                        self.onecmd(f"{requested_cmd} {cmd_args}")
                    except (ValueError, TypeError) as err:
                        print_error(f"Problem with command: {err}")
        except OSError as err:
            print_error(err)

    # -------------------------------------------------------------------------
    # Custom help
    # -------------------------------------------------------------------------

    def do_help(self, arg: str = "") -> None:
        do_help(self, arg)

    def help_all(self) -> None:
        self.do_help()

    @staticmethod
    def help_overview() -> None:
        print(
            textwrap.dedent(
                f"""
        {colorize_str('This utility allows you to interact with the Senzing SDK', 'dim')}

        {colorize_str('Help', 'highlight2')}
            {colorize_str('- View help for a command:', 'dim')} help COMMAND
            {colorize_str('- View all commands:', 'dim')} help all

        {colorize_str('Tab Completion', 'highlight2')}
            {colorize_str('- Tab completion is available for commands, files, engine flags, etc', 'dim')}
            {colorize_str('- Hit tab on a blank line to see all commands', 'dim')}

        {colorize_str('JSON Formatting', 'highlight2')}
            {colorize_str('- Change JSON formatting by adding "json" or "jsonl" to the end of a command', 'dim')}
                - get_entity_by_entity_id 1001 jsonl

            {colorize_str('- Can be combined with color formatting options', 'dim')}
                - get_entity_by_entity_id 1001 jsonl nocolor

            {colorize_str('- Toggle between json and jsonl output for the session, saves the preference to a configuration file for use across sessions', 'dim')}
            {colorize_str('- Specifying the JSON and color formatting options at the end of a command override this setting only for that command', 'dim')}
                - json_format

            {colorize_str('- Convert last response output between json and jsonl', 'dim')}
                - response_reformat_json

        {colorize_str('Color Formatting', 'highlight2')}
            {colorize_str('- Add or remove colors from JSON formatting by adding "color", "colour", "nocolor" or "nocolour" to the end of a command', 'dim')}
                - get_entity_by_entity_id 1001 color

            {colorize_str('- Can be combined with JSON formatting options', 'dim')}
                - get_entity_by_entity_id 1001 color jsonl

            {colorize_str('- Toggle between color or no color for JSON output for the session, saves the preference to a configuration file for use across sessions', 'dim')}
            {colorize_str('- Specifying the JSON and color formatting options at the end of a command override this setting for that command', 'dim')}
                - json_color

        {colorize_str('Capturing Output', 'highlight2')}
            {colorize_str('- Capture the last response output to a file or the clipboard', 'dim')}
                - response_to_clipboard
                - response_to_file /tmp/myoutput.json

        {colorize_str('History', 'highlight2')}
            {colorize_str('- Arrow keys to cycle through history of commands', 'dim')}
            {colorize_str('- Ctrl-r can be used to search history', 'dim')}
            {colorize_str('- Display history:', 'dim')} history

        {colorize_str('Timer', 'highlight2')}
            {colorize_str('- Toggle on/off approximate time a command takes to complete', 'dim')}
            {colorize_str('- Turn off JSON formatting and color output for higher accuracy', 'dim')}
                - timer

        {colorize_str('Shell', 'highlight2')}
            {colorize_str('- Run basic OS shell commands', 'dim')}
                - ! ls

        {colorize_str('Support', 'highlight2')}
            {colorize_str('- Senzing Support:', 'dim')} {colorize_str('https://senzing.zendesk.com/hc/en-us/requests/new', 'highlight1,underline')}
            {colorize_str('- Senzing Knowledge Center:', 'dim')} {colorize_str('https://senzing.zendesk.com/hc/en-us', 'highlight1,underline')}
            {colorize_str('- SDK Docs:', 'dim')} {colorize_str('https://docs.senzing.com', 'highlight1,underline')}

        """
            )
        )

    # -----------------------------------------------------------------------------
    # szconfig commands
    # -----------------------------------------------------------------------------

    @do_methods_decorator
    def do_get_template_config(self) -> None:
        """
        Get a template configuration

        Syntax:
            get_template_config

        """

        config_handle = self.sz_config.create_config()
        response = self.sz_config.export_config(config_handle)
        self.sz_config.close_config(config_handle)
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # szconfigmanager commands
    # -----------------------------------------------------------------------------

    @do_methods_decorator
    def do_get_config(self, **kwargs: Any) -> None:
        """
        Get a configuration

        Syntax:
            get_config config_id

        Example:
            get_config 4180061352

        Arguments:
            config_id = Configuration identifier

        Notes:
            - Retrieve the active configuration identifier with get_active_config_id

            - Retrieve a list of configurations and identifiers with get_configs"""

        response = self.sz_configmgr.get_config(kwargs["parsed_args"].config_id)
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_configs(self) -> None:
        """
        Get a list of current configurations

        Syntax:
            get_configs"""

        response = self.sz_configmgr.get_configs()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_default_config_id(self) -> None:
        """
        Get the default configuration ID

        Syntax:
            get_default_config_id"""

        response = self.sz_configmgr.get_default_config_id()
        self.last_response = self.output_response(response, "success")

    @do_methods_decorator
    def do_replace_default_config_id(self, **kwargs: Any) -> None:
        """
        Replace the default configuration ID

        Syntax:
            replace_default_config_id current_default_config_id new_default_config_id

        Example:
            replace_default_config_id 4180061352 2787925967

        Arguments:
            current_default_config_id = Configuration identifier
            new_default_config_id = Configuration identifier

        Notes:
            - Retrieve a list of configurations and identifiers with get_configs"""

        self.sz_configmgr.replace_default_config_id(
            kwargs["parsed_args"].current_default_config_id,
            kwargs["parsed_args"].new_default_config_id,
        )
        self.output_response("Default config ID replaced", "success")
        self.reinitialize = True
        # self.sz_factory.reinitialize(kwargs["parsed_args"].new_default_config_id)

        # # Configuration has changed, update attributes from configuration
        # self.attrs = self.get_config_attr_codes()

    @do_methods_decorator
    def do_set_default_config_id(self, **kwargs: Any) -> None:
        """
        Set the default configuration ID

        Syntax:
            set_default_config_id config_id

        Example:
            set_default_config_id 4180061352

        Arguments:
            config_id = Configuration identifier

        Notes:
            - Retrieve a list of configurations and identifiers with get_configList"""

        self.sz_configmgr.set_default_config_id(kwargs["parsed_args"].config_id)
        self.output_response("Default config ID set", "success")
        self.reinitialize = True
        # # self.last_response = ""

    # -----------------------------------------------------------------------------
    # szdiagnostic commands
    # -----------------------------------------------------------------------------

    @do_methods_decorator
    def do_check_datastore_performance(self, **kwargs: Any) -> None:
        """
        Run a performance check on the database

        Syntax:
            check_datastore_performance [seconds_to_run]
            check_datastore_performance

        Arguments:
            seconds_to_run = Time in seconds to run the check, default is 3"""

        response = self.sz_diagnostic.check_datastore_performance(kwargs["parsed_args"].seconds_to_run)
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_datastore_info(self) -> None:
        """
        Get data store information

        Syntax:
            get_datastore_info"""

        response = self.sz_diagnostic.get_datastore_info()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_feature(self, **kwargs: Any) -> None:
        """
        Get feature information

        Syntax:
            get_feature feature_id

        Examples:
            get_feature 1

        Arguments:
            feature_id = Identifier of feature"""

        response = self.sz_diagnostic.get_feature(kwargs["parsed_args"].featureID)
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_purge_repository(self, **kwargs: Any) -> None:
        """
        Purge Senzing database of all data

        Syntax:
            purge_repository [--FORCEPURGE]

        Example:
            purge_repository

        Arguments:
            --FORCEPURGE = Don't prompt before purging. USE WITH CAUTION!

        Caution:
            - This deletes all data in the Senzing database!"""

        purge_msg = colorize_output(
            textwrap.dedent(
                """

                ********** WARNING **********

                This will purge all currently loaded data from the senzing database!
                Before proceeding, all instances of senzing (custom code, rest api, redoer, etc.) must be shut down.

                ********** WARNING **********

                Are you sure you want to purge the Senzing database? Type YESPURGESENZING to purge: """
            ),
            "warning",
        )

        if not kwargs["parsed_args"].force_purge:
            if input(purge_msg) != "YESPURGESENZING":
                print("\nSenzing repository not purged\n")
                return

        self.sz_diagnostic.purge_repository()
        print("\nSenzing repository purged\n")

    # -----------------------------------------------------------------------------
    # szengine commands
    # -----------------------------------------------------------------------------

    @do_methods_decorator
    def do_add_record(self, **kwargs: Any) -> None:
        """
        Add a record and optionally return information

        Syntax:
            add_record dsrc_source_code record_id record_definition [-f flag ...]

        Examples:
            add_record test 1 '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}'
            add_record test 1 '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}' -f SZ_WITH_INFO

        Arguments:
            dsrc_source_code = Data source code
            record_id = Record identifier
            record_definition = Senzing mapped JSON representation of a record
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """
        add_record = functools.partial(
            self.sz_engine.add_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
            kwargs["parsed_args"].record_definition,
        )

        response = add_record(kwargs["flags"]) if "flags" in kwargs else add_record()

        if response == "{}":
            self.last_response = self.output_response("Record added", "success")
        else:
            self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_count_redo_records(self) -> None:
        """
        Counts the number of records in the redo queue

        Syntax:
            count_redo_records"""

        response = self.sz_engine.count_redo_records()
        if not response:
            self.last_response = self.output_response("No redo records", "info")
        else:
            self.last_response = self.output_response(response, "success")

    @do_methods_decorator
    def do_delete_record(self, **kwargs: Any) -> None:
        """
        Delete a record and optionally return information

        Syntax:
            delete_record data_source_code record_id [-f flag ...]

        Examples:
            delete_record test 1
            delete_record test 1 -f SZ_WITH_INFO

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        delete_record = functools.partial(
            self.sz_engine.delete_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = delete_record(kwargs["flags"]) if "flags" in kwargs else delete_record()

        if response == "{}":
            self.last_response = self.output_response("Record deleted.", "success")
        else:
            self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_export_csv_entity_report(self, **kwargs: Any) -> None:
        """
        Export repository contents as CSV

        Syntax:
            export_csv_entity_report output_file [-t csv_column_list,...] [-f flag ...]

        Examples:
            export_csv_entity_report export.csv
            export_csv_entity_report export.csv -t RESOLVED_ENTITY_ID,RELATED_ENTITY_ID,MATCH_LEVEL,MATCH_KEY,DATA_SOURCE,RECORD_ID
            export_csv_entity_report export.csv -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_EXPORT_INCLUDE_ALL_ENTITIES

        Arguments:
            output_file = File to save export to
            csv_column_list = Comma separated list of output columns (don't specify for defaults)
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Available csv_column_list columns
                - RESOLVED_ENTITY_ID,RELATED_ENTITY_ID,MATCH_LEVEL,MATCH_KEY,DATA_SOURCE,RECORD_ID,RESOLVED_ENTITY_NAME,ERRULE_CODE,JSON_DATA

            - Engine flag details https://docs.senzing.com/flags/index.html

        Caution:
            - Export isn't intended for exporting large numbers of entities and associated data source record information.
              Beyond 100M+ data source records isn't suggested. For exporting overview entity and relationship data for
              analytical purposes outside of Senzing please review the following article.

              https://senzing.zendesk.com/hc/en-us/articles/360010716274--Advanced-Replicating-the-Senzing-results-to-a-Data-Warehouse
        """
        rec_cnt = 0

        export_csv = functools.partial(
            self.sz_engine.export_csv_entity_report,
            kwargs["parsed_args"].csv_column_list,
        )

        try:
            export_handle = export_csv(kwargs["flags"]) if "flags" in kwargs else export_csv()

            with open(kwargs["parsed_args"].output_file, "w", encoding="utf-8") as csv_out:
                while True:
                    export_record = self.sz_engine.fetch_next(export_handle)
                    if not export_record:
                        break
                    csv_out.write(export_record)
                    rec_cnt += 1
                    if rec_cnt % 1000 == 0:
                        print(f"Exported {rec_cnt} records...", flush=True)
                self.sz_engine.close_export(export_handle)
        except (SzError, IOError) as err:
            print_error(err)
        else:
            self.output_response(f"Total exported records: {rec_cnt}", "success")
            # self.last_response = ""

    @do_methods_decorator
    def do_export_json_entity_report(self, **kwargs: Any) -> None:
        """
        Export repository contents as JSON

        Syntax:
            export_json_entity_report output_file [-f flag ...]

        Examples:
            export_json_entity_report export.json
            export_json_entity_report export.json -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_EXPORT_INCLUDE_ALL_ENTITIES

        Arguments:
            output_file = File to save export to
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html

        Caution:
            - Export isn't intended for exporting large numbers of entities and associated data source record information.
              Beyond 100M+ data source records isn't suggested. For exporting overview entity and relationship data for
              analytical purposes outside of Senzing please review the following article.

              https://senzing.zendesk.com/hc/en-us/articles/360010716274--Advanced-Replicating-the-Senzing-results-to-a-Data-Warehouse
        """

        rec_cnt = 0

        export_json = functools.partial(
            self.sz_engine.export_json_entity_report,
        )

        try:
            export_handle = export_json(kwargs["flags"]) if "flags" in kwargs else export_json()
            with open(kwargs["parsed_args"].output_file, "w", encoding="utf-8") as data_out:
                while True:
                    export_record = self.sz_engine.fetch_next(export_handle)
                    if not export_record:
                        break
                    data_out.write(export_record)
                    rec_cnt += 1
                    if rec_cnt % 1000 == 0:
                        print(f"Exported {rec_cnt} records...", flush=True)
                self.sz_engine.close_export(export_handle)
        except (SzError, IOError) as err:
            print_error(err)
        else:
            self.output_response(f"Total exported records: {rec_cnt}", "success")
            # self.last_response = ""

    @do_methods_decorator
    def do_find_interesting_entities_by_entity_id(self, **kwargs: Any) -> None:
        """
        Find interesting entities close to an entity by resolved entity identifier

        Syntax:
            find_interesting_entities_by_entity_id entity_id [-f flag ...]

        Example:
            find_interesting_entities_by_entity_id 1

        Arguments:
            entity_id = Identifier for an entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html

            - Experimental feature requires additional configuration, contact support@senzing.com
        """

        find_interesting_entities_by_entity_id = functools.partial(
            self.sz_engine.find_interesting_entities_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = (
            find_interesting_entities_by_entity_id(kwargs["flags"])
            if "flags" in kwargs
            else find_interesting_entities_by_entity_id()
        )

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_find_interesting_entities_by_record_id(self, **kwargs: Any) -> None:
        """
        Find interesting entities close to an entity by record identifier

        Syntax:
            find_interesting_entities_by_record_id data_source_code record_id [-f flag ...]

        Example:
            find_interesting_entities_by_record_id customers 1001

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html

            - Experimental feature requires additional configuration, contact support@senzing.com
        """

        find_interesting_entities_by_record_id = functools.partial(
            self.sz_engine.find_interesting_entities_by_record_id,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = (
            find_interesting_entities_by_record_id(kwargs["flags"])
            if "flags" in kwargs
            else find_interesting_entities_by_record_id()
        )

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_find_network_by_entity_id(self, **kwargs: Any) -> None:
        """
        Find network between entities

        Syntax:
            find_network_by_entity_id entity_ids max_degrees build_out_degrees build_out_max_entities [-f flag ...]

        Example:
            find_network_by_entity_id '1 6 9' 4 3 20

        Arguments:
            entity_ids = List of entities to find paths between and networks around (NOTE: quotes around ENTITY_IDS)
            max_degrees = Maximum number of relationships to search for a path
            build_out_degrees = Maximum degree of relationships to include around each entity
            build_out_max_entities = Maximum number of entities to return
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        find_network_by_entity_id = functools.partial(
            self.sz_engine.find_network_by_entity_id,
            kwargs["entity_ids"],
            kwargs["parsed_args"].max_degrees,
            kwargs["parsed_args"].build_out_degrees,
            kwargs["parsed_args"].build_out_max_entities,
        )

        response = find_network_by_entity_id(kwargs["flags"]) if "flags" in kwargs else find_network_by_entity_id()

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_find_network_by_record_id(self, **kwargs: Any) -> None:
        """
        Find network between records

        Syntax:
            find_network_by_record_id record_keys max_degrees build_out_degrees build_out_max_entities [-f flag ...]

        Example:
            find_network_by_record_id 'REFERENCE 2012 CUSTOMERS 1001' 6 4 15

        Arguments:
            record_keys = List of datasource codes and record ID pairs to find paths between and networks around (NOTE: quotes around RECORD_KEYS)
            max_degrees = Maximum number of relationships to search for a path
            build_out_degrees = Maximum degree of relationships to include around each entity
            build_out_max_entities = Maximum number of entities to return
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        find_network_by_record_id = functools.partial(
            self.sz_engine.find_network_by_record_id,
            kwargs["record_keys"],
            kwargs["parsed_args"].max_degrees,
            kwargs["parsed_args"].build_out_degrees,
            kwargs["parsed_args"].build_out_max_entities,
        )

        response = find_network_by_record_id(kwargs["flags"]) if "flags" in kwargs else find_network_by_record_id()

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_find_path_by_entity_id(self, **kwargs: Any) -> None:
        """
        Find a path between two entities

        Syntax:
            find_path_by_entity_id start_entity_id end_entity_id max_degrees [-a avoid_entity_ids] [-r required_data_sources] [-f flag ...]

        Example:
            find_path_by_entity_id 100002 5 3
            find_path_by_entity_id 100002 5 3 -a 259 10
            find_path_by_entity_id 100002 5 3 -a 259 10 -r WATCHLIST

        Arguments:
            start_entity_id = Identifier for an entity
            end_entity_id = Identifier for an entity
            max_degrees = Maximum number of relationships to search for a path
            avoid_entity_ids = Space separated list of entity ID(s) to avoid when finding the path, default is no avoidance
            required_data_sources = Space separated list of data source(s) an entity on the path should have, default is no required data sources
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        find_path_by_entity_id = functools.partial(
            self.sz_engine.find_path_by_entity_id,
            kwargs["parsed_args"].start_entity_id,
            kwargs["parsed_args"].end_entity_id,
            kwargs["parsed_args"].max_degrees,
            kwargs["parsed_args"].avoid_entity_ids,
            kwargs["parsed_args"].required_data_sources,
        )

        response = find_path_by_entity_id(kwargs["flags"]) if "flags" in kwargs else find_path_by_entity_id()

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_find_path_by_record_id(self, **kwargs: Any) -> None:
        """
        Find a path between two records

        Syntax:
            find_path_by_record_id start_dsrc_code start_record_id end_dsrc_code end_record_id max_degrees [-a avoid_record_keys] [-r required_data_sources] [-f flag ...]

        Example:
            find_path_by_record_id reference 2141 reference 2121 6

        Arguments:
            start_dsrc_code = Data source code
            start_record_id = Record identifier
            end_dsrc_code = Data source code
            end_record_id = Record identifier
            max_degrees = Maximum number of relationships to search for a path
            avoid_record_keys = Space separated list of data source code and record IDs to avoid when finding the path, default is no avoidance
            required_data_sources = Space separated list of data source(s) an entity on the path should have, default is no required data sources
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        find_path_by_record_id = functools.partial(
            self.sz_engine.find_path_by_record_id,
            kwargs["parsed_args"].start_data_source_code,
            kwargs["parsed_args"].start_record_id,
            kwargs["parsed_args"].end_data_source_code,
            kwargs["parsed_args"].end_record_id,
            kwargs["parsed_args"].max_degrees,
            kwargs["avoid_record_keys"],
            kwargs["parsed_args"].required_data_sources,
        )

        response = find_path_by_record_id(kwargs["flags"]) if "flags" in kwargs else find_path_by_record_id()

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_active_config_id(self) -> None:
        """
        Get the active configuration identifier

        Syntax:
            get_active_config_id"""

        response = self.sz_engine.get_active_config_id()
        self.last_response = self.output_response(response, color="success")

    @do_methods_decorator
    def do_get_entity_by_entity_id(self, **kwargs: Any) -> None:
        """
        Get entity by resolved entity identifier

        Syntax:
            get_entity_by_entity_id entity_id [-f flag ...]

        Examples:
            get_entity_by_entity_id 1
            get_entity_by_entity_id 1 -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_SUMMARY

        Arguments:
            entity_id = Identifier for an entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_entity = functools.partial(
            self.sz_engine.get_entity_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = get_entity(kwargs["flags"]) if "flags" in kwargs else get_entity()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_entity_by_record_id(self, **kwargs: Any) -> None:
        """
        Get entity by data source code and record identifier

        Syntax:
            get_entity_by_record_id data_source_code record_id [-f flag ...]

        Examples:
        get_entity_by_record_id customers 1001
        get_entity_by_record_id customers 1001 -f SZ_ENTITY_BRIEF_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_SUMMARY

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_entity = functools.partial(
            self.sz_engine.get_entity_by_record_id,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = get_entity(kwargs["flags"]) if "flags" in kwargs else get_entity()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_record(self, **kwargs: Any) -> None:
        """
        Get a record

        Syntax:
            get_record data_source_code record_id [-f flag ...]

        Examples:
            get_record watchlist 2092
            get_record watchlist 2092 -f SZ_RECORD_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_FORMATTED_DATA

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_record = functools.partial(
            self.sz_engine.get_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = get_record(kwargs["flags"]) if "flags" in kwargs else get_record()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_redo_record(self) -> None:
        """
        Get a redo record from the redo queue

        Syntax:
            get_redo_record"""

        response = self.sz_engine.get_redo_record()
        if not response:
            self.last_response = self.output_response("No redo records.", "info")
        else:
            self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_stats(self) -> None:
        """
        Get engine workload statistics for last process

        Syntax:
            get_stats"""

        response = self.sz_engine.get_stats()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_virtual_entity_by_record_id(self, **kwargs: Any) -> None:
        """
        Determine how an entity composed of a given set of records would look

        Syntax:
            get_virtual_entity_by_record_id record_keys [-f FLAG ...]

        Example:
            get_virtual_entity_by_record_id 'REFERENCE 2071 CUSTOMERS 1069'

        Arguments:
            record_keys = List of datasource codes and record ID pairs to find paths between and networks around (NOTE: quotes around RECORD_KEYS)
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        get_virtual = functools.partial(
            self.sz_engine.get_virtual_entity_by_record_id,
            kwargs["record_keys"],
        )

        response = get_virtual(kwargs["flags"]) if "flags" in kwargs else get_virtual()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_how_entity_by_entity_id(self, **kwargs: Any) -> None:
        """
        Retrieve information on how entities are constructed from their records

        Syntax:
            how_entity_by_entity_id entity_id [-f flag ...]

        Example:
            how_entity_by_entity_id 96

        Arguments:
            entity_id = Identifier for an entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        how_entity = functools.partial(
            self.sz_engine.how_entity_by_entity_id,
            kwargs["parsed_args"].entity_id,
        )

        response = how_entity(kwargs["flags"]) if "flags" in kwargs else how_entity()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_prime_engine(self) -> None:
        """
        Prime the Senzing engine

        Syntax:
            prime_engine"""

        self.sz_engine.prime_engine()
        self.last_response = self.output_response("Engine primed.", "success")

    @do_methods_decorator
    def do_process_redo_record(self, **kwargs: Any) -> None:
        """
        Process a redo record fetched from the redo queue

        Syntax:
            process_redo_record redo_record [-f FLAG ...]

        Examples:
            process_redo_record <redo_record>
            process_redo_record <redo_record> -f SZ_WITH_INFO

        Arguments:
            redo_record = A redo record
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        process_redo = functools.partial(
            self.sz_engine.process_redo_record,
            kwargs["parsed_args"].redo_record,
        )

        response = process_redo(kwargs["flags"]) if "flags" in kwargs else process_redo()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_preprocess_record(self, **kwargs: Any) -> None:
        """
        Pre-process a record

        Syntax:
            preprocess_record record_definition [-f flag ...]

        Examples:
            preprocess_record '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}'
            preprocess_record '{"NAME_FULL":"Robert Smith", "DATE_OF_BIRTH":"7/4/1976", "PHONE_NUMBER":"787-767-2088"}' -f SZ_RECORD_DEFAULT_FLAGS

        Arguments:
            record_definition = Senzing mapped JSON representation of a record
            flag = Optional space separated list of engine flag(s) to determine output (don't specify for defaults)
        """

        preprocess_record = functools.partial(
            self.sz_engine.preprocess_record,
            kwargs["parsed_args"].record_definition,
        )

        response = preprocess_record(kwargs["flags"]) if "flags" in kwargs else preprocess_record()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_reevaluate_entity(self, **kwargs: Any) -> None:
        """
        Reevaluate an entity and optionally return information

        Syntax:
            reevaluate_entity entity_id [-f FLAG ...]

        Example:
            reevaluate_entity 1

            reevaluate_entity 1 -f SZ_WITH_INFO

        Arguments:
            entity_id = Entity identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        reevaluate = functools.partial(
            self.sz_engine.reevaluate_entity,
            kwargs["parsed_args"].entity_id,
        )

        response = reevaluate(kwargs["flags"]) if "flags" in kwargs else reevaluate()
        if response == "{}":
            self.last_response = self.output_response("Entity reevaluated", "success")
        else:
            self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_reevaluate_record(self, **kwargs: Any) -> None:
        """
        Reevaluate a record and optionally return information

        Syntax:
            reevaluate_record data_source_code record_id [-f FLAG ...]

        Examples:
            reevaluate_record customers 1001
            reevaluate_record customers 1001 -f SZ_WITH_INFO

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        reevaluate = functools.partial(
            self.sz_engine.reevaluate_record,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = reevaluate(kwargs["flags"]) if "flags" in kwargs else reevaluate()
        if response == "{}":
            self.last_response = self.output_response("Record reevaluated", "success")
        else:
            self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_search_by_attributes(self, **kwargs: Any) -> None:
        # search_by_attributes ATTRIBUTES [SEARCH_PROFILE] [-f FLAG ...]
        # search_by_attributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}' SEARCH -f SZ_SEARCH_BY_ATTRIBUTES_MINIMAL_ALL
        # SEARCH_PROFILE = Search profile to use (defaults to SEARCH)
        """
        Search for entities

        Syntax:
            search_by_attributes attributes [-f FLAG ...]

        Examples:
            search_by_attributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}'
            search_by_attributes '{"name_full":"Robert Smith", "date_of_birth":"11/12/1978"}' -f SZ_SEARCH_BY_ATTRIBUTES_MINIMAL_ALL

        Arguments:
            attributes = Senzing mapped JSON containing the attributes to search on
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        if "flags" in kwargs:
            response = self.sz_engine.search_by_attributes(
                kwargs["parsed_args"].attributes,
                kwargs["flags"],
                kwargs["parsed_args"].search_profile,
            )
        else:
            response = self.sz_engine.search_by_attributes(
                kwargs["parsed_args"].attributes,
                search_profile=kwargs["parsed_args"].search_profile,
            )

        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_why_entities(self, **kwargs: Any) -> None:
        """
        Determine how entities relate to each other

        Syntax:
            why_entities entity_id_1 entity_id_2 [-f flag ...]

        Examples:
            why_entities 96 200011
            why_entities 96 200011 -f SZ_WHY_ENTITY_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_RECORD_DEFINITION

        Arguments:
            entity_id_1 = Identifier for first entity
            entity_id_2 = Identifier for second entity
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        why_entities = functools.partial(
            self.sz_engine.why_entities,
            kwargs["parsed_args"].entity_id_1,
            kwargs["parsed_args"].entity_id_2,
        )

        response = why_entities(kwargs["flags"]) if "flags" in kwargs else why_entities()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_why_record_in_entity(self, **kwargs: Any) -> None:
        """
        Determine why a particular record resolved to an entity

        Syntax:
            why_record_in_entity data_source_code record_id [-f FLAG ...]

        Examples:
            why_record_in_entity reference 2121
            why_record_in_entity reference 2121 -f SZ_WHY_ENTITY_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_RECORD_DEFINITION

        Arguments:
            data_source_code = Data source code
            record_id = Record identifier
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        why_record = functools.partial(
            self.sz_engine.why_record_in_entity,
            kwargs["parsed_args"].data_source_code,
            kwargs["parsed_args"].record_id,
        )

        response = why_record(kwargs["flags"]) if "flags" in kwargs else why_record()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_why_records(self, **kwargs: Any) -> None:
        """
        Determine how two records relate to each other

        Syntax:
            why_records data_source_code_1 record_id_1 data_source_code_2 record_id_2 [-f flag ...]

        Examples:
            why_records reference 2121 watchlist 2092
            why_records reference 2121 watchlist 2092 -f SZ_WHY_ENTITY_DEFAULT_FLAGS SZ_ENTITY_INCLUDE_RECORD_RECORD_DEFINITION

        Arguments:
            data_source_code_1 = Data source code for first record
            record_id_1 = Identifier for first record
            data_source_code_2 = Data source code for second record
            record_id_2 = Identifier for second record
            flag = Space separated list of engine flag(s) to determine output (don't specify for defaults)

        Notes:
            - Engine flag details https://docs.senzing.com/flags/index.html"""

        why_records = functools.partial(
            self.sz_engine.why_records,
            kwargs["parsed_args"].data_source_code_1,
            kwargs["parsed_args"].record_id_1,
            kwargs["parsed_args"].data_source_code_2,
            kwargs["parsed_args"].record_id_2,
        )

        response = why_records(kwargs["flags"]) if "flags" in kwargs else why_records()
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # szproduct commands
    # -----------------------------------------------------------------------------

    @do_methods_decorator
    def do_get_license(self) -> None:
        """
        Get license information

        Syntax:
            get_license"""

        response = self.sz_product.get_license()
        self.last_response = self.output_response(response)

    @do_methods_decorator
    def do_get_version(self) -> None:  # pylint: disable=invalid-name
        """
        Get version information

        Syntax:
            get_version"""

        response = self.sz_product.get_version()
        self.last_response = self.output_response(response)

    # -----------------------------------------------------------------------------
    # Custom commands
    # -----------------------------------------------------------------------------

    def do_hidden(self, line: str) -> None:  # pylint: disable=unused-argument
        print()
        print("\n".join(map(str, self.__hidden_cmds)))
        print()

    def do_history(self, line: str) -> None:  # pylint: disable=unused-argument
        """
        Displays the command history

        Syntax:
            history
        """
        do_history()

    def do_json_color(self, line: str) -> None:  # pylint: disable=unused-argument
        """
        Enables/disables adding colors to JSON responses for the session and saves preference

        Syntax:
            json_color
        """
        self.color_json = not self.color_json
        print_info(f'Coloring of JSON responses {"enabled" if self.color_json else "disabled"}')

        self.write_config()

    def do_json_format(self, line: str) -> None:  # pylint: disable=unused-argument
        """
        Switch output between json (tall json) and jsonl (json lines) for JSON responses for the session and saves preference

        Syntax:
            json_format
        """
        self.format_json = not self.format_json
        print_info(f'Formatting of JSON responses {"enabled" if self.format_json else "disabled"}')

        self.write_config()

    def do_response_to_clipboard(self, line: str) -> None:  # pylint: disable=[unused-argument]
        """
        Attempt to copy the last command response to the clipboard

        Syntax:
            response_to_clipboard
        """
        response_to_clipboard(self.last_response)

    # TODO - Ant -Update help for append and command
    @do_methods_decorator
    def do_response_to_file(self, **kwargs: Any) -> None:
        """
        Attempt to copy the last command response to a file

        Syntax:
            response_to_file output_file

        Arguments:
            output_file = File to save response to
        """
        response_to_file(
            kwargs["parsed_args"].file_path,
            kwargs["parsed_args"].append_to_file,
            kwargs["parsed_args"].add_command,
            self.last_command,
            self.last_response,
        )

    def do_response_reformat_json(self, line: str) -> None:  # pylint: disable=[unused-argument]
        """
        Convert the last response between json and jsonl formatting

        Syntax:
            response_reformat_json
        """
        self.last_response = response_reformat_json(self.last_response, self.color_json, self.color_disabled)

    def do_scroll_output(self, line: str) -> None:  # pylint: disable=[unused-argument]
        """
        Switch output between using a pager or not

        Syntax:
            scroll_output
        """
        self.scroll_output = not self.scroll_output
        print_info(f'Paging of JSON responses {"enabled" if self.scroll_output else "disabled"}')

        self.write_config()

    @do_methods_decorator
    def do_set_theme(self, **kwargs: Any) -> None:
        """
        Switch terminal ANSI colors

        Syntax:
            set_theme default|dark|light|{terminal}

        Note:
            - The default is terminal and recommended
        """
        Colors.set_theme(kwargs["parsed_args"].theme[0])
        self.theme = kwargs["parsed_args"].theme[0]
        self.write_config()

    def do_timer(self, line: str) -> None:  # pylint: disable=unused-argument
        """
        Toggle on/off displaying an approximate time for commands to complete

        Syntax:
            timer

        """
        self.timer = not self.timer
        print_info(f'Timer {"enabled" if self.timer else "disabled"}')
        self.write_config()

    # -----------------------------------------------------------------------------
    # Helper methods
    # -----------------------------------------------------------------------------

    # TODO - Ant -
    def remove_per_cmd_settings(self, cmd_line: str) -> str:
        """#TODO"""
        # TODO - Ant -
        # Remove any formatters from input command list and convert back to a string
        cmd_list = [c for c in cmd_line.split() if c.lower() not in PER_CMD_FORMATTERS]
        cmd_line_cleaned = " ".join(cmd_list)

        return cmd_line_cleaned

    # TODO - Ant - Rename method as it will do more than formats - timer, debug, scroll
    def apply_formats(
        self,
        cmd_line: str,
    ) -> str:
        """Check command for optional formatters, apply them and remove formatters from the command before running it"""
        # Convert command str to a list, lower each element to check if any formatters are present
        cmd_list_lower = [x.lower() for x in cmd_line.split()]
        formatting = [f for f in PER_CMD_FORMATTERS if f in cmd_list_lower]

        # Set formatters if any are found on the input command
        if formatting:
            # Input command as a list to remove any formatters
            cmd_list = cmd_line.split()

            for format_ in formatting:
                if format_ in ["json", "jsonl"]:
                    self.cmd_format = True
                    if format_ == "json":
                        self.format_json_cmd = True
                    if format_ == "jsonl":
                        self.format_json_cmd = False

                if format_ in [
                    "color",
                    "colour",
                    "nocolor",
                    "nocolour",
                ]:
                    self.cmd_color = True
                    if format_ in ["color", "colour"]:
                        self.color_json_cmd = True
                    if format_ in ["nocolor", "nocolour"]:
                        self.color_json_cmd = False

            # TODO - Ant -
            # Remove any formatters from input command list and convert back to a string
            # cmd_list = [c for c in cmd_list if c not in PER_CMD_FORMATTERS]
            # cmd_line = " ".join(cmd_list)
        cmd_line_cleaned = self.remove_per_cmd_settings(cmd_line)

        return cmd_line_cleaned

    # Parses command arguments into a list of argument strings
    def parse(self, argument_string: str) -> List[str]:
        try:
            return shlex.split(argument_string)
        except ValueError as err:
            print_error(f"Unable to parse arguments: {err}")
            raise

    def read_config(self) -> None:
        try:
            with open(self.config_file, "r", encoding="utf-8") as _:
                pass
            config_parser = configparser.ConfigParser()
            config_parser.read(self.config_file)
            self.format_json = config_parser["CONFIG"].getboolean("format_json")
            self.color_json = config_parser["CONFIG"].getboolean("output_color")
            self.timer = config_parser["CONFIG"].getboolean("timer")
            self.theme = config_parser["CONFIG"]["theme"]
            self.scroll_output = config_parser["CONFIG"].getboolean("scroll_output")
            self.debug_sdk_call = config_parser["CONFIG"].getboolean("debug_sdk_call")
        except IOError as err:
            print_warning(
                f"Error reading configuration file {self.config_file}: {err}",
            )
        except (configparser.Error, KeyError) as err:
            print_warning(
                f"Error reading entries from configuration file {self.config_file}: {err}",
            )

    def write_config(self) -> None:
        if self.docker_launched:
            return

        write_config = configparser.ConfigParser()
        write_config["CONFIG"] = {
            "format_json": f'{"True" if self.format_json else "False"}',
            "output_color": f'{"True" if self.color_json else "False"}',
            "timer": f'{"True" if self.timer else "False"}',
            "theme": self.theme,
            "scroll_output": f'{"True" if self.scroll_output else "False"}',
            "debug_sdk_call": f'{"True" if self.scroll_output else "False"}',
        }

        try:
            with open(self.config_file, "w", encoding="utf-8") as config_file:
                write_config.write(config_file)
        except IOError as err:
            if not self.config_error:
                print_warning(
                    f"Error saving configuration to {self.config_file}: {err}",
                )
                self.config_error = not self.config_error
        except configparser.Error as err:
            if not self.config_error:
                print_warning(
                    f"Error writing entries to the configuration file {self.config_file}: {err}",
                )
                self.config_error = not self.config_error

    # -------------------------------------------------------------------------
    # Auto completers
    # -------------------------------------------------------------------------

    # pylint: disable=[unused-argument]

    # Auto complete engine flags from self.szengineflags
    def flags_completes(self, text: str, line: str) -> List[str]:
        flags = []
        if re.match(".* -f +", line):
            flags = [flag for flag in self.engine_flags_list if flag.lower().startswith(text.lower())]
        return flags

    # Auto complete engine flags and JSON key/value syntax
    def json_and_flags_completes(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        # Do not change the order of these matches!

        # comp_cmd = re.match(r"\w+ +", line)
        comp_cmd = re.match(r"\w+ +\w+ +\w+ +", line)
        if comp_cmd and len(comp_cmd.group()) == len(line):
            # print(f"{comp_cmd.group() = }")
            return ["""'{"": "", """]

        re_flags = re.search(" -f +.*$", line)
        if re_flags and re_flags.end() == endidx:
            flags = [flag for flag in self.engine_flags_list if flag.lower().startswith(text.lower())]
            return flags

        # re_j_start = re.search("'{{1}", line)
        re_j_start = re.match(r"\w+ +\w+ +\w+ +'{{1}", line)
        if re_j_start:

            # Look ahead a couple of characters...
            attr_check = line[begidx : begidx + 2]

            if re.search("'{", line[begidx:]):
                return []

            if attr_check == '":' or re.match(r"\w", attr_check):
                attrs = [attr for attr in self.attrs if attr.lower().startswith(text.lower())]
                return attrs

            if not text and line[begidx - 1 :] == '"':
                return ["}' "]

        return []

    @staticmethod
    def path_completes(
        text: str,
        line: str,
        begidx: int,
        endidx: int,
        calling_cmd: str,
    ) -> List[str]:
        """Auto complete paths for commands"""

        completes = []
        path_comp = line[len(calling_cmd) + 1 : endidx]
        fixed = line[len(calling_cmd) + 1 : begidx]
        for path in glob.glob(f"{path_comp}*"):
            path = path + os.sep if path and os.path.isdir(path) and path[-1] != os.sep else path
            completes.append(path.replace(fixed, "", 1))

        return completes

    def complete_add_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.json_and_flags_completes(text, line, begidx, endidx)

    def complete_delete_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_export_csv_entity_report(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("export_csv_entity_report +", line) and not re.match("export_csv_entity_report +.* +", line):
            return self.path_completes(text, line, begidx, endidx, "export_csv_entity_report")

        if re.match(".* -f +", line):
            return self.flags_completes(text, line)
        return []

    def complete_export_json_entity_report(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("export_json_entity_report +", line) and not re.match("export_json_entity_report +.* +", line):
            return self.path_completes(text, line, begidx, endidx, "export_json_entity_report")

        if re.match(".* -f +", line):
            return self.flags_completes(text, line)
        return []

    def complete_find_interesting_entities_by_entity_id(
        self, text: str, line: str, begidx: int, endidx: int
    ) -> List[str]:
        return self.flags_completes(text, line)

    def complete_find_interesting_entities_by_record_id(
        self, text: str, line: str, begidx: int, endidx: int
    ) -> List[str]:
        return self.flags_completes(text, line)

    def complete_find_network_by_entity_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_find_network_by_record_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_find_path_by_entity_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_find_path_by_record_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_get_entity_by_entity_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_get_entity_by_record_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_get_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_get_virtual_entity_by_record_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_how_entity_by_entity_id(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_preprocess_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.json_and_flags_completes(text, line, begidx, endidx)

    def complete_process_redo_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_reevaluate_entity(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_reevaluate_record(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_search_by_attributes(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        # return self.flags_completes(text, line)
        return self.json_and_flags_completes(text, line, begidx, endidx)

    def complete_why_record_in_entity(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_why_entities(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    def complete_why_records(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        return self.flags_completes(text, line)

    # TODO - Ant - Update to not complete if append/command added now
    def complete_response_to_file(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("response_to_file +", line):
            return self.path_completes(text, line, begidx, endidx, "response_to_file")
        return []

    def complete_set_theme(self, text: str, line: str, begidx: int, endidx: int) -> List[str]:
        if re.match("set_theme +", line):
            return [theme for theme in self.themes if theme.lower().startswith(text.lower())]
        return []

    # pylint: enable=[unused-argument]


def parse_cli_args() -> argparse.Namespace:
    """Parse the CLI arguments"""
    arg_parser = argparse.ArgumentParser(
        allow_abbrev=False,
        description="Utility to interact with Senzing APIs",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    arg_parser.add_argument(
        "-c",
        "--ini-file",
        help="optional path and file name of G2Module.ini to use",
    )
    non_interactive_group = arg_parser.add_mutually_exclusive_group()
    non_interactive_group.add_argument(
        "-C",
        "--command",
        action="append",
        nargs="+",
        help="run command(s) without starting an interactive session",
    )
    non_interactive_group.add_argument(
        "-f",
        "--file-to-process",
        default=None,
        help="path and file name of file with commands to run",
        nargs="?",
    )
    arg_parser.add_argument(
        "-t",
        "--debug_trace",
        action="store_true",
        default=False,
        help="output debug information",
    )
    arg_parser.add_argument(
        "-cd",
        "--color_disable",
        action="store_true",
        default=False,
        help="disable coloring of output, color formatting commands will have no effect in the session",
    )
    arg_parser.add_argument(
        "-H",
        "--hist_disable",
        action="store_true",
        default=False,
        help="disable use of history file",
    )

    return arg_parser.parse_args()


def main() -> None:
    """main"""

    cli_args = parse_cli_args()

    # Check an engine configuration can be located
    engine_config = get_engine_config(cli_args.ini_file)

    cmd_obj = SzCmdShell(engine_config, cli_args)

    # Execute commands and catch ctrl-c
    try:
        # Execute command(s) non-interactively from the command line
        if cli_args.command:
            cmd_obj.commands_from_cli(cli_args.command)
            return

        # Execute a file of commands
        if cli_args.file_to_process:
            cmd_obj.commands_from_file(cli_args.file_to_process)
            return

        # Interactive session
        cmd_obj.cmdloop()
    except KeyboardInterrupt:
        return


if __name__ == "__main__":
    main()
