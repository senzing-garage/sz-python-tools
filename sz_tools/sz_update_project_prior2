#! /usr/bin/env python3
# TODO - sz_project_update
# TODO -
# TODO -
# TODO -
# TODO -
# TODO -

# TODO -
"""Upgrade a V3 or V4 Senzing SDK project"""

import argparse
import json
import shutil
import sys
from contextlib import suppress
from dataclasses import dataclass
from pathlib import Path
from time import sleep
from typing import Any

INPUT_CONFS = ("y", "Y", "yes", "YES")
MODULE_NAME = Path(__file__).stem
# TODO -
# V3_PROJ_BUILD = "g2BuildVersion.json"
# V4_PROJ_BUILD = "szBuildVersion.json"
V3_BUILD = "g2BuildVersion.json"
V4_BUILD = "szBuildVersion.json"
V3_SYS_PATH = Path("/opt/senzing/g2")
V4_SYS_PATH = Path("/opt/senzing/er")
V3_SYS_BUILD = V3_SYS_PATH / V3_BUILD
V4_SYS_BUILD = V4_SYS_PATH / V4_BUILD
V3_BACKUP_PATH = "v3_upgrade_backups"
UPGRADE_URL = "https://www.senzing.com/docs/4_beta/index.html"

V3_BACKUP_PROJ = {
    "bin": {"files": ["g2dbencrypt", "g2saltadm", "g2ssadm"], "excludes": []},
    "etc": {"files": ["senzing_governor.py"], "excludes": []},
    "lib": {"files": ["libSpaceTimeBoxStandardizer.so", "libG2Hasher.so", "libG2SSAdm.so"], "excludes": []},
    "python": {"files": [], "excludes": []},
    "resources/templates": {"files": ["setupEnv"], "excludes": []},
    "setupEnv": {"files": [], "excludes": []},
    "g2BuildVersion.json": {"files": [], "excludes": []},
}

V3_REMOVE_FROM_PROJ = {
    "bin": {"files": ["*"], "excludes": ["bin"]},
    "data": {"files": [], "excludes": []},
    "etc": {"files": ["senzing_governor.py"], "excludes": []},
    # "g2BuildVersion.json": {"files": [], "excludes": []},
    "lib": {
        "files": [
            "g2.jar",
            "libG2.so",
            "libG2Hasher.so",
            "libG2SSAdm.so",
            "libg2CompJavaScoreSet.so",
            "libg2DistinctFeatJava.so",
            "libg2EFeatJava.so",
            "libg2JVMPlugin.so",
            "libg2StdJava.so",
            "libmariadbplugin.so",
            "libSpaceTimeBoxStandardizer.so",
        ],
        "excludes": ["lib"],
    },
    "python": {"files": ["*"], "excludes": []},
    "resources/config": {"files": ["g2core-configuration-upgrade-*.gtc"], "excludes": []},
    "resources/schema": {"files": ["g2core-schema-*-create.sql", "g2core-schema-*-upgrade-*.sql"], "excludes": []},
    "resources/templates": {
        "files": [
            "G2C.db*",
            "G2Module.ini",
            "custom*.txt",
            "defaultGNRCP.config",
            "g2config.json",
            "senzing_governor.py",
            "setupEnv",
            "stb.config",
        ],
        "excludes": [],
    },
    "sdk": {"files": ["*"], "excludes": ["sdk"]},
    "setupEnv": {"files": [], "excludes": []},
}

# TODO -
# V3_COPY_TO_PROJ = {
#     "LICENSE": {"files": [], "excludes": []},
#     "NOTICES": {"files": [], "excludes": []},
#     "README.1ST": {"files": [], "excludes": []},
#     "bin": {"files": ["*"], "excludes": ["sz_create_project", "sz_update_project"]},
#     "/opt/senzing/data": {"files": ["*"], "excludes": []},
#     "lib": {"files": ["*"], "excludes": []},
#     "resources": {"files": ["*"], "excludes": []},
#     "sdk": {"files": ["*"], "excludes": []},
#     "szBuildVersion.json": {"files": [], "excludes": []},
# }
COPY_TO_PROJ = {
    "LICENSE": {"files": [], "excludes": []},
    "NOTICES": {"files": [], "excludes": []},
    "README.1ST": {"files": [], "excludes": []},
    "bin": {"files": ["*"], "excludes": ["sz_create_project", "sz_update_project"]},
    "/opt/senzing/data": {"files": ["*"], "excludes": []},
    "lib": {"files": ["*"], "excludes": []},
    "resources": {"files": ["*"], "excludes": []},
    "sdk": {"files": ["*"], "excludes": []},
    "szBuildVersion.json": {"files": [], "excludes": []},
}


V3_RENAME_IN_PROJ = {
    "etc": {"from": "G2Module.ini", "to": "sz_engine_config.ini"},
}


V3_RESET_PERMISSIONS = {
    ".": {
        "dir_pint": 0,
        "file_pint": 0o660,
        "files": ["LICENSE", "NOTICES", "README.1ST", "szBuildVersion.json"],
        "excludes": ["setupEnv"],
        "recursive": False,
    },
    "setupEnv": {"dir_pint": 0, "file_pint": 0o770, "files": [], "excludes": [], "recursive": False},
    "bin": {
        "dir_pint": 0o770,
        "file_pint": 0o770,
        "files": ["*"],
        "excludes": ["__pycache__", "_sz_database.py", "_tool_helpers.py"],
        "recursive": False,
    },
    "data": {"dir_pint": 0o770, "file_pint": 0o660, "files": ["*"], "excludes": [], "recursive": True},
    "lib": {"dir_pint": 0o770, "file_pint": 0o660, "files": ["*"], "excludes": [], "recursive": False},
    "resources": {"dir_pint": 0o770, "file_pint": 0o660, "files": ["*"], "excludes": ["setupEnv"], "recursive": True},
    "resources/templates/setupEnv": {
        "dir_pint": 0,
        "file_pint": 0o770,
        "files": [],
        "excludes": [],
        "recursive": False,
    },
    "sdk": {"dir_pint": 0o770, "file_pint": 0o660, "files": ["*"], "excludes": [], "recursive": True},
    "v3_upgrade_backups": {"dir_pint": 0o770, "file_pint": 0, "files": [], "excludes": [], "recursive": False},
}


# TODO -
# VersionTokens = namedtuple("VersionTokens", ["major", "minor", "patch"])
# class VersionDetails(NamedTuple):
@dataclass()
class VersionDetails:
    """Version information for a project or Senzing SDK system install"""

    version: str
    major: int
    minor: int
    patch: int

    def __post_init__(self) -> None:
        self.sum_mmp = sum((self.major, self.minor, self.patch))


# pylint: disable=W0106


def parse_cli_args() -> argparse.Namespace:
    """Parse the CLI arguments"""
    arg_parser = argparse.ArgumentParser(
        description="Update an existing Senzing project to the system installed version of Senzing."
    )
    arg_parser.add_argument(
        "project_path",
        metavar="path",
        help="path of the project to update",
    )
    arg_parser.add_argument(
        "-f",
        "--force",
        dest="force_mode",
        default=False,
        action="store_true",
        help="upgrade without prompts. WARNING: Use with caution, ensure you have a backup of the project",
    )
    return arg_parser.parse_args()


def dir_listing(path: Path) -> list[Path]:
    """Get a listing of the specified path to check for files or directories"""
    try:
        listing = list(path.iterdir())
    except OSError as err:
        if type(err).__name__ == "NotADirectoryError":
            print(f"\nERROR: {path} is not a directory, expecting one")
        print(f"\nERROR: {err}")
        sys.exit(1)

    return listing


def pre_check(project_path: Path) -> tuple[VersionDetails, VersionDetails]:
    """Check not trying to overwrite the V4 Senzing system install, that path is a project, and versions are correct"""
    if not V4_SYS_PATH.exists():
        print(f"\nERROR: Couldn't locate Senzing SDK V4 system install at {V4_SYS_PATH}")
        sys.exit(1)

    if str(project_path).startswith(str(V4_SYS_PATH.parent)):
        print(f"\nERROR: {project_path} is the Senzing system installation, not a Senzing project")
        sys.exit(1)

    v3_project_build_file = project_path / V3_BUILD
    v4_project_build_file = project_path / V4_BUILD
    proj_listing = dir_listing(project_path)
    if v3_project_build_file not in proj_listing and v4_project_build_file not in proj_listing:
        print(f"\nERROR: {project_path} isn't a Senzing project, expected it to contain either:")
        print(f"\tExisting V3 project - {v3_project_build_file}")
        print(f"\tExisting V4 project - {v4_project_build_file}")
        sys.exit(1)

    try:
        proj_build_file = v3_project_build_file if v3_project_build_file in proj_listing else v4_project_build_file
        # proj_version, proj_version_tokens = get_build_version(proj_build_file)
        # sys_version, sys_version_tokens = get_build_version(V4_SYS_BUILD)
        proj_version_details = get_build_version(proj_build_file)
        sys_version_details = get_build_version(V4_SYS_BUILD)
    except OSError as err:
        print(f"\nERROR: Trying to read {proj_build_file} or {V4_SYS_BUILD} to collect version information: {err}")
        sys.exit(1)

    # if proj_version_tokens.major not in (3, 4) or sys_version_tokens.major != 4:
    if proj_version_details.major not in (3, 4) or sys_version_details.major != 4:
        print(f"\nERROR: {MODULE_NAME} updates a V3 project to V4, or V4.n.n to a newer release")
        print(f"\tProject version: {proj_version_details.major}, system install version: {sys_version_details.major}")
        sys.exit(1)

    if proj_version_details.major == 4 and sys_version_details.sum_mmp == proj_version_details.sum_mmp:
        print(f"No update required, project and system install are the same version - {proj_version_details.version}")
        sys.exit(0)

    return (proj_version_details, sys_version_details)


# TODO - Move to helpers?
def get_build_version(path: Path) -> VersionDetails:
    """Return the version string and major, minor, and patch versions from a build file"""
    err_msg = f"ERROR: Couldn't get the version information from {path}"

    try:
        with open(path, "r", encoding="utf-8") as f:
            version_str: str = json.load(f)["VERSION"]
    except (OSError, json.JSONDecodeError) as err:
        print(f"\n{err_msg}: {err}")
        sys.exit(1)
    except KeyError as err:
        print(f"\n{err_msg}, missing key {err}")
        sys.exit(1)

    if not (str_tokens := version_str.split(".")) or (str_tokens and str_tokens[0] == ""):
        print(f"\n{err_msg}, VERSION was blank")
        sys.exit(1)

    if len(str_tokens) != 3:
        print(f"\nERROR: Version information should consist of major, minor, and patch, it is {version_str}")
        sys.exit(1)

    try:
        # TODO -
        # vers_tokens = VersionDetails._make([int(v) for v in str_tokens])
        # int_tokens = [int(v) for v in str_tokens]
        return VersionDetails(version_str, *[int(v) for v in str_tokens])
        # vers_tokens = VersionDetails(version_str, str_tokens)
    except ValueError:
        print(f"\nERROR: Version information should consist of integers, it is {version_str}")
        sys.exit(1)

    # TODO -
    # return (version_str, vers_details)


def remove_dir(dir_: Path, excludes: list[Path]) -> None:
    """Recursively remove a directory"""
    try:
        for path in dir_.iterdir():
            if path in excludes:
                continue
            path.unlink(missing_ok=True) if (path.is_file() or path.is_symlink()) else remove_dir(path, excludes)

        if not excludes:
            with suppress(FileNotFoundError):
                dir_.rmdir()
    except OSError as err:
        raise err


def remove_files_dirs(to_remove: dict[str, Any], target_dir: Path) -> None:
    """Remove files/directories that are no longer required"""
    for r_path, r_dict in to_remove.items():
        target: Path = target_dir / r_path
        files = r_dict["files"]
        excludes = [target / e for e in r_dict["excludes"]]

        try:
            if target.is_file() or target.is_symlink():
                target.unlink(missing_ok=True)

            if target.is_dir() and not files or (files and files[0] == "*"):
                remove_dir(target, excludes)

            if target.is_dir() and files and files[0] != "*":
                target_files = []
                for f in files:
                    target_files.append(target / f) if "*" not in f else target_files.extend(list(target.glob(f)))

                for target_file in target_files:
                    target_file.unlink(missing_ok=True)
        except OSError as err:
            raise OSError(f"ERROR: Couldn't delete a file or directory: {err}") from err


def copy_files_dirs(to_copy: dict[str, Any], source_dir: Path, target_dir: Path) -> None:
    # def copy_files_dirs(to_copy: dict[str, Any], source_dir: Path, target_dir: Path, sz_sys_path: Path) -> None:
    """Copy files/directories within and to a project"""
    # TODO -
    print(f"\n{to_copy = }", flush=True)
    print(f"\n{source_dir = }", flush=True)
    print(f"\n{target_dir = }", flush=True)
    # print(f"\n{sz_sys_path = }", flush=True)
    for c_path, c_dict in to_copy.items():
        excludes = c_dict["excludes"]
        files = c_dict["files"]
        source: Path = source_dir / c_path
        target: Path = target_dir / c_path

        if c_path.startswith("/"):
            source = Path(c_path)
            try:
                # TODO -
                # target = target_dir / source.relative_to(SZ_SYS_PATH)
                # target = target_dir / source.relative_to(sz_sys_path)
                target = target_dir / source.relative_to(V4_SYS_PATH)
            except ValueError:
                target = target_dir / target.name

        try:
            if source.is_file():
                shutil.copy(
                    source,
                    target,
                )

            if source.is_dir() and not files or (files and files[0] == "*"):
                shutil.copytree(source, target, ignore=shutil.ignore_patterns(*excludes), dirs_exist_ok=True)

            if source.is_dir() and files and files[0] != "*":
                target.mkdir(exist_ok=True, parents=True)
                for source_file in [source / f for f in files]:
                    shutil.copy(source_file, target / source_file.name)
        except OSError as err:
            raise OSError(f"ERROR: Couldn't copy a file or directory: {err}") from err


def rename_files(to_rename: dict[str, dict[str, str]], target_dir: Path) -> None:
    """Rename existing project files that had a name change"""

    try:
        for r_path, r_dict in to_rename.items():
            current = target_dir / r_path / r_dict["from"]
            new = target_dir / r_path / r_dict["to"]
            with suppress(FileNotFoundError):
                current.rename(new)
    except OSError as err:
        raise OSError(f"ERROR: Couldn't rename a file or directory: {err}") from err


def setup_env(proj_path: Path) -> None:
    """Create a new setupEnv and replace place holders with paths for the project"""
    try:
        shutil.copy(proj_path / "resources/templates/setupEnv", proj_path)
        setup_path = proj_path / "setupEnv"

        with open(setup_path, "r", encoding="utf-8") as in_:
            data = in_.read()

        data = data.replace("${SENZING_DIR}", str(proj_path)).replace("${SENZING_CONFIG_PATH}", str(proj_path / "etc"))

        with open(setup_path, "w", encoding="utf-8") as out:
            out.write(data)
    except OSError as err:
        raise OSError(f"ERROR: Couldn't create a new setupEnv file: {err}") from err


def set_permissions(proj_path: Path, permissions: dict[str, dict[str, Any]]) -> None:
    """Set permissions for files/dirs copied to the project, or dirs removed and replaced completely e.g., data/"""
    try:
        for p_path, p_dict in permissions.items():
            dir_pint = p_dict["dir_pint"]
            file_pint = p_dict["file_pint"]
            files = p_dict["files"]
            recursive = p_dict["recursive"]
            target = proj_path if p_path.startswith(".") else proj_path / p_path
            excludes = [target / e for e in p_dict["excludes"]]

            if target.is_file():
                target.chmod(file_pint)

            if target.is_dir() and dir_pint != 0:
                target.chmod(dir_pint)
                d_chmods = (
                    [d for d in target.glob("*") if d.is_dir() and not d.is_symlink() and d not in excludes]
                    if not recursive
                    else [d for d in target.rglob("*") if d.is_dir() and not d.is_symlink() and d not in excludes]
                )
                for dir_ in d_chmods:
                    dir_.chmod(dir_pint)

            if target.is_dir() and (files and files[0] == "*"):
                f_chmods = (
                    [f for f in target.glob("*") if f.is_file() and not f.is_symlink() and f not in excludes]
                    if not recursive
                    else [f for f in target.rglob("*") if f.is_file() and not f.is_symlink() and f not in excludes]
                )
                for file in f_chmods:
                    Path(target / file).chmod(file_pint)

            if target.is_dir() and files and files[0] != "*":
                for file in files:
                    Path(target / file).chmod(file_pint)
    except OSError as err:
        raise OSError(f"ERROR: Couldn't set a permission: {err}") from err


def main() -> None:
    """main"""
    cli_args = parse_cli_args()
    proj_path = Path(cli_args.project_path).resolve()
    proj_versions, sys_versions = pre_check(proj_path)
    proj_is_v3 = bool(proj_versions.major == 3)
    # sz_sys_path = V3_SYS_PATH if proj_is_v3 else V4_SYS_PATH

    if not cli_args.force_mode:
        print(f"\nWARNING: If you don't have a backup of the project ({proj_path}), create one before continuing!")
        sleep(3)
        if (
            input(
                f"\nContinue updating the project from version {proj_versions.version} to {sys_versions.version}? (y/n) "
            )
            not in INPUT_CONFS
        ):
            sys.exit(0)
        print("\nUpdating...")
    else:
        print(f"\nUpdating project from version {proj_versions.version} to {sys_versions.version}...")

    try:
        if proj_is_v3:
            v3_backup_path = proj_path / V3_BACKUP_PATH
            v3_backup_path.mkdir(exist_ok=True)
            # copy_files_dirs(
            #     V3_BACKUP_PROJ, proj_path, v3_backup_path, sz_sys_path
            # )  # Backup some of the V3 project files
            copy_files_dirs(V3_BACKUP_PROJ, proj_path, v3_backup_path)  # Backup some of the V3 project files
            rename_files(V3_RENAME_IN_PROJ, proj_path)
            remove_files_dirs(V3_REMOVE_FROM_PROJ, proj_path)

        # rename_files(V3_RENAME_IN_PROJ, proj_path)
        # remove_files_dirs(V3_REMOVE_FROM_PROJ, proj_path)
        # copy_files_dirs(COPY_TO_PROJ, SZ_SYS_PATH, proj_path)
        # copy_files_dirs(COPY_TO_PROJ, sz_sys_path, proj_path, sz_sys_path)
        # copy_files_dirs(COPY_TO_PROJ, sz_sys_path, proj_path, V4_SYS_PATH)
        copy_files_dirs(COPY_TO_PROJ, V4_SYS_PATH, proj_path)
        # setup_env(proj_path)
        if proj_is_v3:
            setup_env(proj_path)
        set_permissions(proj_path, V3_RESET_PERMISSIONS)
    except OSError as err:
        shutil.copytree(v3_backup_path, proj_path, dirs_exist_ok=True)
        print(f"\n{err}")
        print(
            "\nIf the error is file or directory permission related, run again with a user with appropriate privileges"
        )
        print(
            "\nIf the error is missing file or directory, check senzingsdk-setup, senzingsdk-tools, and senzingsdk-poc are installed"
        )
    else:
        if proj_is_v3:  # Remove if no errors, otherwise re-running can find the file
            # proj_path.joinpath(PROJ_BUILD).unlink(missing_ok=True)
            proj_path.joinpath(V3_BUILD).unlink(missing_ok=True)
        print(f"\nProject successfully updated. Refer to {UPGRADE_URL} for additional upgrade instructions")


if __name__ == "__main__":
    main()
